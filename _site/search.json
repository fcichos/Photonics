[
  {
    "objectID": "lectures/lecture01/02-lecture01.html",
    "href": "lectures/lecture01/02-lecture01.html",
    "title": "Optical Elements Part II",
    "section": "",
    "text": "Code\nbk7=pd.read_csv(\"data/BK7.csv\",delimiter=\",\")\nsf10=pd.read_csv(\"data/SF10.csv\",delimiter=\",\")\nfk51a=pd.read_csv(\"data/FK51A.csv\",delimiter=\",\")\nplt.figure(figsize=(4,4))\nplt.plot(bk7.wl*1000,bk7.n,label=\"BK7\")\nplt.plot(sf10.wl*1000,sf10.n,label=\"SF10\")\nplt.plot(fk51a.wl*1000,fk51a.n,label=\"FK51A\")\nplt.xlim(300,900)\nplt.xlabel(\"wavelength [nm]\")\nplt.ylabel(\"refractive index n\")\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 1— Refractive index of different glasses as a function of the wavelength."
  },
  {
    "objectID": "lectures/lecture01/lecture1_outline.html",
    "href": "lectures/lecture01/lecture1_outline.html",
    "title": "Photonics",
    "section": "",
    "text": "Maxwell’s equations overview\nLight as electromagnetic waves\nKey properties: polarization, dispersion\nSpeed of light derivation\nElectromagnetic spectrum\nConnection between wave optics and electromagnetic theory"
  },
  {
    "objectID": "lectures/lecture01/lecture1_outline.html#electromagnetic-theory-15-minutes",
    "href": "lectures/lecture01/lecture1_outline.html#electromagnetic-theory-15-minutes",
    "title": "Photonics",
    "section": "",
    "text": "Maxwell’s equations overview\nLight as electromagnetic waves\nKey properties: polarization, dispersion\nSpeed of light derivation\nElectromagnetic spectrum\nConnection between wave optics and electromagnetic theory"
  },
  {
    "objectID": "lectures/lecture01/lecture1_outline.html#quantum-nature-of-light-15-minutes",
    "href": "lectures/lecture01/lecture1_outline.html#quantum-nature-of-light-15-minutes",
    "title": "Photonics",
    "section": "Quantum Nature of Light (15 minutes)",
    "text": "Quantum Nature of Light (15 minutes)\n\nWave-particle duality introduction\nPhoton concept preview\nEnergy quantization\nBrief mention of photon statistics\nModern quantum optics applications"
  },
  {
    "objectID": "lectures/lecture01/lecture1_outline.html#comparative-analysis-and-conclusion-5-minutes",
    "href": "lectures/lecture01/lecture1_outline.html#comparative-analysis-and-conclusion-5-minutes",
    "title": "Photonics",
    "section": "Comparative Analysis and Conclusion (5 minutes)",
    "text": "Comparative Analysis and Conclusion (5 minutes)\n\nDomains of validity for different light models\nWhen to use which description\nUnified perspective on the nature of light\nPreview of upcoming lectures\nQ&A"
  },
  {
    "objectID": "lectures/lecture02/02-lecture02.html",
    "href": "lectures/lecture02/02-lecture02.html",
    "title": "Theories for light",
    "section": "",
    "text": "Wave optics extends our understanding beyond the limitations of geometric optics by treating light as a wave phenomenon. This approach explains effects that cannot be accounted for by ray tracing alone, such as:\n\nInterference (the combination of waves)\nDiffraction (the bending of waves around obstacles or through apertures)\nColor (the wavelength-dependent nature of light)\n\nLight is part of the electromagnetic spectrum, which spans an enormous range of frequencies. The visible region, extending approximately from 400 nm (violet) to 700 nm (red), represents only a small fraction of this spectrum. This wave description is essential for understanding many optical phenomena that geometric optics cannot explain, particularly when dealing with structures comparable in size to the wavelength of light.\n\n\n\n\n\n\nFigure 1— Electromagnetic Spectrum with its different regions\n\n\n\nIn the following, we would like to introduce wave by discarding the fact, that light is related to electric and magnetic fields. This is useful as the vectorial nature of the electric and magnetic field further complicates the calculations, but we do not need those yet. Accordingly we also do not understand how light really interacts with matter and we therefore have to introduce some postulates as well.",
    "crumbs": [
      "Home",
      "FOUNDATIONS OF PHOTONICS",
      "Lecture 2",
      "Wave Optics Introduction"
    ]
  },
  {
    "objectID": "lectures/lecture02/02-lecture02.html#postulates-of-wave-optics",
    "href": "lectures/lecture02/02-lecture02.html#postulates-of-wave-optics",
    "title": "Theories for light",
    "section": "Postulates of Wave Optics",
    "text": "Postulates of Wave Optics\n\n\n\n\n\n\nWave\n\n\n\nA wave corresponds to a physical quantity which oscillates in space and time. Its energy current density is related to the square magnitude of the amplitude. A wave satisfies the wave equation.\n\n\n\nWave equation\n\\[\n\\nabla^2 u - \\frac{1}{c^2}\\frac{\\partial^2 u}{\\partial t^2}=0\n\\]\nwhere the Laplace operator \\(\\nabla^2\\) is defined as:\n\\[\n\\nabla^2 =\\frac{\\partial^2}{\\partial x^2}+\\frac{\\partial^2}{\\partial y^2}+\\frac{\\partial^2}{\\partial z^2}\n\\]\nThe wave equation is a linear differential equation, which implies that the superposition principle holds. Specifically, if \\(u_1(\\mathbf{r},t)\\) and \\(u_2(\\mathbf{r},t)\\) are solutions of the wave equation, then any linear combination:\n\\[\nu(\\mathbf{r},t)=a_1u_1(\\mathbf{r},t)+a_2u_2(\\mathbf{r},t)\n\\]\nis also a solution, where \\(a_1\\) and \\(a_2\\) are arbitrary constants.\n\n\nMonochromatic Wave\nA monochromatic wave consists of a single frequency \\(\\omega\\). By definition, such a wave must be infinite in time and free from phase disturbances (such as sudden jumps). The mathematical expression for a monochromatic wave is:\n\\[u(\\mathbf{r},t)=a(\\mathbf{r})\\cos(\\omega t + \\phi(\\mathbf{r}))\\]\nwhere:\n\n\\(a(\\mathbf{r})\\) represents the amplitude\n\\(\\phi(\\mathbf{r})\\) represents the spatial phase\n\\(\\omega\\) represents the angular frequency\n\n\n\n\n\n\n\nFigure 2— Representation of a wavefunction over time (constant position) denoting the phase \\(\\phi\\) and the period \\(T=1/\\nu\\)\n\n\n\n\nComplex Amplitude\nThe wave can be represented in complex form as:\n\\[\nU(\\mathbf{r},t)=a(\\mathbf{r})e^{i\\phi(\\mathbf{r})}e^{i\\omega t}\n\\]\nThis is known as the complex wavefunction.\n\n\n\n\n\n\nFigure 3— Phasor diagram of the complex amplitude \\(U(\\mathbf{r})\\) (left) and \\(U(t)\\) (right)\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nA phasor displays the complex amplitude with magnitude and phase as a vector in the complex plane.\n\n\nThe relationship between the complex and real wavefunctions is:\n\\[\nu(\\mathbf{r},t)=\\text{Re}\\{U(\\mathbf{r},t)\\}=\\frac{1}{2}[U(\\mathbf{r},t)+U^*(\\mathbf{r},t)]\n\\]\nThe complex wavefunction satisfies the same wave equation:\n\\[\n\\nabla^2 U - \\frac{1}{c^2}\\frac{\\partial^2 U}{\\partial t^2}=0\n\\]\nWe can separate the complex wavefunction into spatial and temporal components:\n\\[\nU(\\mathbf{r},t)=U(\\mathbf{r})e^{i\\omega t}\n\\]\nwhere\n\\[\nU(\\mathbf{r})=a(\\mathbf{r})e^{i\\phi(\\mathbf{r})}\n\\]\nHere, \\(\\phi\\) represents the spatial phase of the wavefunction. Substituting this into the wave equation and noting that the time derivatives bring down factors of \\(i\\omega\\):\n\\[\\nabla^2 [U(\\mathbf{r})e^{i\\omega t}] - \\frac{1}{c^2}\\frac{\\partial^2}{\\partial t^2}[U(\\mathbf{r})e^{i\\omega t}] = 0\\] \\[\\nabla^2 U(\\mathbf{r})e^{i\\omega t} + \\frac{\\omega^2}{c^2}U(\\mathbf{r})e^{i\\omega t} = 0\\]\nThe time dependence \\(e^{i\\omega t}\\) factors out, leaving us with the Helmholtz equation:\n\\[\\nabla^2 U(\\mathbf{r}) + k^2U(\\mathbf{r}) = 0\\]\nwhere \\(k = \\omega/c\\) is the wave number. This equation describes the spatial behavior of monochromatic waves.\n\n\nIntensity of Waves\nThe intensity of a wave at position \\(\\mathbf{r}\\) and time \\(t\\) is defined as:\n\\[\nI(\\mathbf{r},t)=2\\langle u^2(\\mathbf{r},t)\\rangle\n\\]\nwhere \\(I\\) is measured in units of \\(\\left[\\frac{W}{m^2}\\right]\\). The angle brackets \\(\\langle \\ldots \\rangle\\) represent a time average over one oscillation cycle of \\(u\\). For visible light, this averaging occurs over an extremely brief period - for example, light with a wavelength of 600 nm has a cycle duration of just 2 femtoseconds.\nThe optical power \\(P\\) of a wave can be calculated by integrating the intensity over a surface area \\(A\\):\n\\[\nP=\\int_A I(\\mathbf{r},t) \\, dA\n\\]\nInserting the seperation of the complex wavefunction into spatial and temporal components leads to the following expression for the intensity:\n\\[\nI(\\mathbf{r})=|U(\\mathbf{r})|^2\n\\]\nThus the physical quantity forming the spatial and temporal oscillation of the wavefunction is also providing the intensity of the wave when its magnitude is squared. This is a fundamental property of wavefunctions and for example not the case when temperature oscillates in space and time in a medium.\n\n\nWavefronts\nWavefronts are surfaces in space where the phase is constant:\n\\[\n\\phi(\\mathbf{r})=\\text{const}\n\\]\nTypically, this constant is chosen to represent points of maximum spatial amplitude, such that:\n\\[\n\\phi(\\mathbf{r})=2\\pi q\n\\]\nwhere \\(q\\) is an integer.\nThe direction normal to these wavefronts can be described by the gradient vector:\n\\[\n\\mathbf{n}=\\nabla\\phi=\\left(\\frac{\\partial \\phi}{\\partial x},\\frac{\\partial \\phi}{\\partial y},\\frac{\\partial \\phi}{\\partial z}\\right)\n\\]\nThis vector \\(\\mathbf{n}\\) is always perpendicular to the wavefront surface and points in the direction of wave propagation. The evolution of these wavefronts in time provides important information about the wave’s propagation characteristics.",
    "crumbs": [
      "Home",
      "FOUNDATIONS OF PHOTONICS",
      "Lecture 2",
      "Wave Optics Introduction"
    ]
  },
  {
    "objectID": "lectures/lecture02/02-lecture02.html#plane-waves",
    "href": "lectures/lecture02/02-lecture02.html#plane-waves",
    "title": "Theories for light",
    "section": "Plane Waves",
    "text": "Plane Waves\nA plane wave represents a fundamental solution of the homogeneous wave equation. In its complex form, it is expressed as:\n\\[\\begin{equation}\nU(\\mathbf{r},t)=Ae^{-i\\mathbf{k}\\cdot \\mathbf{r}}e^{i\\omega t}\n\\end{equation}\\]\nwhere:\n\nThe first exponential term contains the spatial phase\nThe second exponential term contains the temporal phase\n\\(A\\) is the (potentially complex) amplitude of the plane wave\n\nThe wavefront of a plane wave is defined by:\n\\[\\mathbf{k}\\cdot \\mathbf{r}=2\\pi q + \\text{arg}(A)\\]\nwhere \\(1\\) is an integer. It just means that the projection of the position vector \\(\\mathbf{r}\\) onto the wavevector \\(\\mathbf{k}\\) is a multiple of \\(2\\pi\\). This equation describes a plane perpendicular to the wavevector \\(\\mathbf{k}\\). Adjacent wavefronts are separated by the wavelength \\(\\lambda=2\\pi/k\\), where \\(k\\) represents the spatial frequency of the wave oscillation.\nThe spatial component of the plane wave is given by:\n\\[\\begin{equation}\nU(\\mathbf{r})=Ae^{-i\\mathbf{k}\\cdot \\mathbf{r}}\n\\end{equation}\\]\nIn vacuum, the wavevector \\(\\mathbf{k}=\\mathbf{k}_0\\) is real-valued and can be written as:\n\\[\\begin{equation}\n\\mathbf{k}_0=\n\\begin{pmatrix}\nk_{0x} \\\\\nk_{0y}\\\\\nk_{0z}\\\\\n\\end{pmatrix}\n\\end{equation}\\]\n\n\nCode\ndef plane_wave(k,omega,r,t):\n    return(np.exp(1j*(np.dot(k,r)-omega*t)))\n\nwavelength=532e-9\nk0=2*np.pi/wavelength\nc=299792458\nomega0=k0*c\n\nvec=np.array([0.0,0.,1.])\nvec=vec/np.sqrt(np.dot(vec,vec))\n\nk=k0*vec\n\nx=np.linspace(-2.5e-6,2.5e-6,300)\nz=np.linspace(0,5e-6,300)\n\nX,Z=np.meshgrid(x,z)\nr=np.array([X,0,Z],dtype=object)\n\nplt.figure(figsize=get_size(6,6))\n\nfield=plane_wave(k,omega0,r,0)\n\nextent = np.min(z)*1e6, np.max(z)*1e6,np.min(x)*1e6, np.max(x)*1e6\nplt.imshow(np.real(field.transpose()),extent=extent,vmin=-1,vmax=1,cmap='seismic')\nplt.xlabel('z-position [µm]')\nplt.ylabel('x-position [µm]')\n\nplt.show()\n\n\n\n\n\n\n\n\nFigure 4— Plane wave propagating along the z-direction",
    "crumbs": [
      "Home",
      "FOUNDATIONS OF PHOTONICS",
      "Lecture 2",
      "Wave Optics Introduction"
    ]
  },
  {
    "objectID": "lectures/lecture02/02-lecture02.html#dispersion-relation",
    "href": "lectures/lecture02/02-lecture02.html#dispersion-relation",
    "title": "Theories for light",
    "section": "Dispersion Relation",
    "text": "Dispersion Relation\nUsing the plane wave solution\n\\[\\begin{equation}\nU(\\mathbf{r},t)=Ae^{-i\\mathbf{k}\\cdot \\mathbf{r}}e^{i\\omega t}\n\\end{equation}\\]\nwe can write down the sum of the spatial and temporal phase as\n\\[\n\\phi(r,t)=\\omega t-\\mathbf{k}\\cdot \\mathbf{r}\n\\]\nIf we select a point on the wavefront \\(\\mathbf{r}_{m}\\), and follow that over time, the phase \\(\\phi(t)=\\text{const}\\). Taking the time derivative results in\n\\[\n\\mathbf{k}\\cdot \\frac{d\\mathbf{r}_{m}}{dt}=\\omega\n\\]\nIf we choose the direction of the wavevector for measuring the propagation speed, i.e. \\(\\mathbf{r}_{m}=r_{m}\\mathbf{e}_k\\) then we find for the propagation speed\n\\[\n\\frac{dr_{m}}{dt}=\\frac{\\omega}{k}\n\\]\nor in vacuum\n\\[\\begin{equation}\nc_0=\\frac{\\omega}{k_0}\n\\end{equation}\\]\nThis fundamental relationship connects:\n\nThe momentum (\\(k\\)),\nThe energy (\\(\\omega\\))\n\nand is called a dispersion relation despite the fact, that we do not really understand why those quantities are related to energy and momentum.\n\n\n\n\n\n\nNote\n\n\n\nLight in free space exhibits a linear dispersion relation, i.e. the frequency of light changes linearly with the wavevector magnitude.\n\n\nNote that if we choose a different propagation direction \\(\\mathbf{e}\\) than the one along the wavevector \\(\\mathbf{e}_k\\), we can write the phase velocity as\n\\[\n\\mathbf{k}\\cdot\\mathbf{e} \\frac{dr}{dt}=k\\cos(\\measuredangle\\mathbf{k},\\mathbf{e}) \\frac{dr}{dt}=\\omega\n\\]\nor\n\\[\n\\frac{dr}{dt}=\\frac{\\omega}{k\\cos(\\measuredangle\\mathbf{k},\\mathbf{e})}\n\\]\nwhich means that if you observe the wavepropagation not in the direction of the wavevector, the phase velocity is actually bigger than the speed of light and even tends to infinity if the angle between the wavevector and the observation direction tends to 90°.",
    "crumbs": [
      "Home",
      "FOUNDATIONS OF PHOTONICS",
      "Lecture 2",
      "Wave Optics Introduction"
    ]
  },
  {
    "objectID": "lectures/lecture02/02-lecture02.html#propagation-in-a-medium",
    "href": "lectures/lecture02/02-lecture02.html#propagation-in-a-medium",
    "title": "Theories for light",
    "section": "Propagation in a Medium",
    "text": "Propagation in a Medium\nWhen a wave propagates through a medium:\n\nThe frequency \\(\\omega\\) remains constant (determined by the source)\nThe wave speed changes according to: \\[\nc=\\frac{c_0}{n}\n\\] where \\(n\\) is the refractive index of the medium\n\nThis leads to changes in:\n\nthe wavelength, which becomes shorter in the medium \\[\n\\lambda=\\frac{\\lambda_0}{n}\n\\]\nthe length of the wavevector, which increases in the medium \\[\nk=nk_0\n\\]",
    "crumbs": [
      "Home",
      "FOUNDATIONS OF PHOTONICS",
      "Lecture 2",
      "Wave Optics Introduction"
    ]
  },
  {
    "objectID": "lectures/lecture02/02-lecture02.html#snells-law",
    "href": "lectures/lecture02/02-lecture02.html#snells-law",
    "title": "Theories for light",
    "section": "Snells Law",
    "text": "Snells Law\nThe change in the length of the wavevector has some simple consequence for Snells law. We can write Snells law as\n\\[\nn_1k_0\\sin(\\theta_1)=n_2k_0\\sin(\\theta_2)\n\\]\nwhere \\(k_0\\) is the wavevector length in vacuum. As the \\(n_1k_0\\) is the magnitude of the wavevector in medium 1, and \\(n_2k_0\\) is the magnitude of the wavevector in medium 2, we can rewrite Snells law as\n\\[\nk_1\\sin(\\theta_1)=k_2\\sin(\\theta_2)\n\\]\nwhich means that the component of the wavevector parallel to the interface is conserved. If the wavevector has constant length then the wavevector incident at different angles is between a point on a circle and the origin in the diagram below. The circle corresponds to an isofrequency surface.\n\nCode\ntheta_upper = np.linspace(0, np.pi, 100)  # Upper half circle\ntheta_lower = np.linspace(np.pi, 2*np.pi, 100)  # Lower half circle\n\n# Radii for the circles\nr1 = 1.51  # Radius for upper half circle\nr2 = 1.01  # Radius for lower half circle\n\nx_upper = r1 * np.cos(theta_upper)\ny_upper = r1 * np.sin(theta_upper)\n\nx_lower = r2 * np.cos(theta_lower)\ny_lower = r2 * np.sin(theta_lower)\n\n# Create the plot\nplt.figure(figsize=get_size(4, 3),dpi=150)\nplt.plot(x_upper, y_upper, 'b-', label=f'Upper radius = {r1}')\nplt.plot(x_lower, y_lower, 'r-', label=f'Lower radius = {r2}')\n\n# Add arrow\n# Calculate arrow start point (on the upper circle at 135 degrees)\narrow_start_x = r1 * np.cos(3*np.pi/4.2)  # 135 degrees in radians\narrow_start_y = r1 * np.sin(3*np.pi/4.2)\n# Add arrow to origin (0,0)\nplt.arrow(arrow_start_x, arrow_start_y, -arrow_start_x, -arrow_start_y,\n          head_width=0.1, head_length=0.2, fc='b', ec='b',\n          length_includes_head=True, label='45° arrow')\n\ndy=np.sqrt(r2**2-arrow_start_x**2)\nplt.arrow(0, 0, -arrow_start_x, -dy,\n          head_width=0.1, head_length=0.2, fc='r', ec='r',\n          length_includes_head=True, label='45° arrow')\n\nplt.axhline(y=0, color='k', linestyle='-', alpha=0.3)\nplt.axvline(x=0, color='k', linestyle='-', alpha=0.3)\nplt.axvline(x=-arrow_start_x, color='k', linestyle='--',lw=0.5)\nplt.axvline(x=arrow_start_x, color='k', linestyle='--', lw=0.5)\n\nplt.axis('square')\n\nplt.grid(True, alpha=0.3)\nplt.xlabel(r'$k_x/k_0$')\nplt.ylabel(r'$k_y/k_0$')\nplt.xlim(-2,2 )\nplt.ylim(-2,2 )\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\nSnells law construction using the conservation of the wavevector component parallel to the interface. The vertical dashed lines indicate the parallal component of the wavevector in the two media.\n\n\n\n\n\n\n\n\nElectron microscopy image of a 2D photonic crystal\n\n\n\n\n\n\n\nIsofrequency surfaces of a photonic crystal\n\n\n\n\n\nIsofrequency surfaces can have non-spherical shape. In anisotropic media, they can be ellipsoids. In photonic crystals, i.e. crystals with a periodic structure on the scale of the wavelength, they can have a more complex shape.",
    "crumbs": [
      "Home",
      "FOUNDATIONS OF PHOTONICS",
      "Lecture 2",
      "Wave Optics Introduction"
    ]
  },
  {
    "objectID": "lectures/lecture02/02-lecture02.html#spherical-waves",
    "href": "lectures/lecture02/02-lecture02.html#spherical-waves",
    "title": "Theories for light",
    "section": "Spherical Waves",
    "text": "Spherical Waves\nA spherical wave, like a plane wave, consists of spatial and temporal components, but with wavefronts forming spherical surfaces. For spherical waves, \\(|\\mathbf{k}||\\mathbf{r}|=kr=\\text{const}\\). Given a source at position \\(\\mathbf{r}_0\\), the spherical wave can be expressed as:\n\\[\\begin{equation}\nU=\\frac{A}{|\\mathbf{r}-\\mathbf{r}_0|}e^{-ik|\\mathbf{r}-\\mathbf{r}_0|} e^{i\\omega t}\n\\end{equation}\\]\n\n\n\n\n\n\nImportant\n\n\n\nThe \\(1/|\\mathbf{r}-\\mathbf{r}_0|\\) factor in the amplitude is necessary for energy conservation - ensuring that the total energy flux through any spherical surface centered on the source remains constant.\n\n\n\n\nCode\ndef spherical_wave(k,omega,r,r0,t):\n    k=np.linalg.norm(k)\n    d=np.linalg.norm(r-r0)\n    return( np.exp(1j*(k*d-omega*t))/d)\n\nplt.figure(figsize=get_size(5,5),dpi=150)\n\nx=np.linspace(-5e-6,5e-6,300)\nz=np.linspace(-5e-6,5e-6,300)\n\nX,Z=np.meshgrid(x,z)\nr=np.array([X,0,Z],dtype=object)\n\nwavelength=532e-9\nk0=2*np.pi/wavelength\nc=299792458\nomega0=k0*c\n\nk=k0*np.array([0,0,1.])\nr0=np.array([0,0,0])\n\nfield=spherical_wave(k,omega0,r,r0,0)\n\nextent = np.min(z)*1e6, np.max(z)*1e6,np.min(x)*1e6, np.max(x)*1e6\nplt.imshow(np.real(field.transpose()),extent=extent,vmin=-5e6,vmax=5e6,cmap='seismic')\n\nplt.xlabel('z [µm]')\nplt.ylabel('x [µm]')\nplt.show()\n\n\n\n\n\n\n\n\nFigure 5— Spherical wave propagation. The wave is emitted from the origin and propagates in the positive z-direction. The wavefronts are spherical surfaces. The wave is visualized in the xz-plane.\n\n\n\n\n\nNote: The direction of wave propagation can be reversed by changing the sign of the wavenumber \\(k\\).",
    "crumbs": [
      "Home",
      "FOUNDATIONS OF PHOTONICS",
      "Lecture 2",
      "Wave Optics Introduction"
    ]
  },
  {
    "objectID": "lectures/lecture02/01-lecture02.html",
    "href": "lectures/lecture02/01-lecture02.html",
    "title": "Theories for light",
    "section": "",
    "text": "Refraction at Spherical Surfaces\nWhen light encounters a spherical boundary between two media, we can analyze its path using Snell’s law and geometric considerations as shown below:\n\n\n\n\n\n\nFigure 1— Refraction at a curved surface.\n\n\n\nTo determine how an image forms, we need to find where rays originating from a point at distance \\(a\\) from the surface will converge after refraction. Using Snell’s law for a ray hitting the surface at angle \\(\\alpha+\\theta_1\\):\n\\[n_{1}\\sin(\\alpha+\\theta_1)=n_{2}\\sin(\\alpha-\\theta_2)\\]\nWhere: \\[\\sin(\\alpha)=\\frac{y}{R}, \\quad \\tan(\\theta_1)=\\frac{y}{a}, \\quad \\tan(\\theta_2)=\\frac{y}{b}\\]\nFor practical optical systems, we employ the paraxial approximation, where all angles are assumed small enough that:\n\\[\\sin(\\theta) \\approx \\theta+ O(\\theta^{3}), \\quad \\tan(\\theta) \\approx \\theta + O(\\theta^{3}),\\quad \\cos(\\theta)\\approx 1 + O(\\theta^{2})\\]\nThis simplifies Snell’s law to:\n\\[n_1(\\alpha+\\theta_1)=n_2(\\alpha-\\theta_2)\\]\nAfter appropriate transformations (detailed in the online lecture), we obtain:\n\\[\\theta_2=\\frac{n_2-n_1}{n_2 R}y -\\frac{n_1}{n_2}\\theta_1\\]\nand\n\\[y=y_1=y_2\\]\nThis linear relationship between input (\\(y\\), \\(\\theta_1\\)) and output (\\(y\\),\\(\\theta_2\\)) parameters is a hallmark of paraxial optics and a result of the linearization of Snells law.\n\n\nMatrix Optics\nThe linear relation between input and output parameters allows us to express optical elements as linear transformations (matrices). This approach forms the foundation of matrix optics. For a lens, the matrix representation is:\n\\[\\begin{pmatrix} y_2 \\\\ \\theta_2 \\end{pmatrix} = \\begin{pmatrix} 1 & 0 \\\\ -\\frac{1}{f} & 1 \\end{pmatrix} \\begin{pmatrix} y_1 \\\\ \\theta_1 \\end{pmatrix}\\]\nThis 2×2 matrix is called the ABCD matrix of the lens. Thanks to the linearization of Snell’s law, we can generalize this to any optical element:\n\\[\\begin{pmatrix} y_2 \\\\\n\\theta_2 \\end{pmatrix} = \\begin{pmatrix} A & B \\\\ C & D \\end{pmatrix} \\begin{pmatrix} y_1 \\\\ \\theta_1 \\end{pmatrix}\\]\nEach element in the ABCD matrix has a specific physical meaning:\n\n\n\n\n\n\n\nMatrix Element\nPhysical Meaning\n\n\n\n\nA\nMagnification - relates output position to input position\n\n\nB\nPosition-to-angle conversion - relates output position to input angle\n\n\nC\nFocusing power - relates output angle to input position\n\n\nD\nAngular magnification - relates output angle to input angle\n\n\n\nEvery optical element can be characterized by these parameters. For example, a lens has C = -1/f (focusing power), while free space has B = d (position-dependent angle change). An important property is that the determinant of the matrix equals the ratio of refractive indices: det(M) = n₁/n₂, which equals 1 in a single medium.\nHere are the ABCD matrices for common optical elements:\n\\[\n\\mathbf{M}=\\begin{bmatrix}\nA & B\\\\\nC & D\n\\end{bmatrix} =\\left[\\begin{array}{ll}\n1 & d \\\\\n0 & 1\n\\end{array}\\right] \\tag{Free space}\n\\]\n\\[\n\\mathbf{M}=\\left[\\begin{array}{cc}\n1 & 0 \\\\\n0 & \\frac{n_1}{n_2}\n\\end{array}\\right] \\tag{Planar interface}\n\\]\n\\[\n\\mathbf{M}=\\left[\\begin{array}{cc}\n1 & 0 \\\\\n-\\frac{\\left(n_2-n_1\\right)}{n_2 R} & \\frac{n_1}{n_2}\n\\end{array}\\right] \\tag{Spherical Boundary}\n\\]\n\\[\n\\mathbf{M}=\\left[\\begin{array}{cc}\n1 & 0 \\\\\n-\\frac{1}{f} & 1\n\\end{array}\\right] \\tag{Thin Lens}\n\\]\nFor a system containing multiple optical elements, we simply multiply their matrices in the order that light passes through them:\n\\[\n\\mathrm{M}=\\mathbf{M}_N \\cdots \\mathbf{M}_2 \\mathbf{M}_1\n\\]\nA ray entering the first optical element at a height \\(y_1\\) at an angle \\(\\theta_1\\) is transformed according to the matrix \\(\\mathbf{M}\\) by the whole system. This elegant approach provides a powerful tool for analyzing complex optical systems efficiently.\n\n\n\n\n\n\nExample: Optical Cloaking with Lens Systems\n\n\n\n\n\nOptical cloaking refers to making objects “invisible” by guiding light rays around them such that to an observer, it appears as if the rays traveled through free space without encountering any object. Using matrix optics, we can design such a system.\n\n\n\n\n\n\nFigure 2— Example of a practical paraxial cloak. (a)–(c) A hand is cloaked for varying directions, while the background image is transmitted properly.(d) On-axis view of the ray optics cloaking device. (e) Setup using practical, easy to obtain optics, for demonstrating paraxial cloaking principles. (Photos by J. Adam Fenster, videos by Matthew Mann / University of Rochester) Source\n\n\n\nFor perfect optical cloaking, the ABCD matrix of our system must be equivalent to that of free space:\n\\[\n\\mathbf{M}_{cloaking} = \\left[\\begin{array}{cc}\n1 & d \\\\\n0 & 1\n\\end{array}\\right]\n\\]\nWhere \\(d\\) is the total effective optical path length. Let’s explore why we need exactly 4 lenses to achieve this.\n\nAnalysis of Different Lens Configurations\n1. Single Lens Configuration\nFor a single lens with focal length \\(f\\), the ABCD matrix is:\n\\[\n\\mathbf{M}_{single} = \\left[\\begin{array}{cc}\n1 & 0 \\\\\n-\\frac{1}{f} & 1\n\\end{array}\\right]\n\\]\nThis clearly cannot match the free space matrix due to the non-zero \\(C\\) element.\n2. Two-Lens Configuration\nFor two lenses with focal lengths \\(f_1\\) and \\(f_2\\) separated by distance \\(d_{12}\\):\n\\[\n\\mathbf{M}_{two} = \\left[\\begin{array}{cc}\n1 & 0 \\\\\n-\\frac{1}{f_2} & 1\n\\end{array}\\right]\n\\left[\\begin{array}{cc}\n1 & d_{12} \\\\\n0 & 1\n\\end{array}\\right]\n\\left[\\begin{array}{cc}\n1 & 0 \\\\\n-\\frac{1}{f_1} & 1\n\\end{array}\\right]\n\\]\nWhen \\(d_{12} = f_1 + f_2\\) (telescopic arrangement), this simplifies to:\n\\[\n\\mathbf{M}_{two} = \\left[\\begin{array}{cc}\n-\\frac{f_1}{f_2} & 0 \\\\\n0 & -\\frac{f_2}{f_1}\n\\end{array}\\right]\n\\]\nSince both magnification (\\(A\\)) and angular magnification (\\(D\\)) cannot simultaneously equal 1 while maintaining \\(\\det(\\mathbf{M}) = 1\\), two lenses are insufficient.\n3. Three-Lens Configuration\nWith three lenses, we have more parameters but still need to determine if we can satisfy all constraints simultaneously. For a three-lens system with focal lengths \\(f_1\\), \\(f_2\\), and \\(f_3\\), separated by distances \\(d_{12}\\) and \\(d_{23}\\), the system matrix would be:\n\\[\n\\mathbf{M}_{three} =\n\\left[\\begin{array}{cc}\n1 & 0 \\\\\n-\\frac{1}{f_3} & 1\n\\end{array}\\right]\n\\left[\\begin{array}{cc}\n1 & d_{23} \\\\\n0 & 1\n\\end{array}\\right]\n\\left[\\begin{array}{cc}\n1 & 0 \\\\\n-\\frac{1}{f_2} & 1\n\\end{array}\\right]\n\\left[\\begin{array}{cc}\n1 & d_{12} \\\\\n0 & 1\n\\end{array}\\right]\n\\left[\\begin{array}{cc}\n1 & 0 \\\\\n-\\frac{1}{f_1} & 1\n\\end{array}\\right]\n\\]\nWhen multiplied out, the focusing power (C element) of the system is:\n\\[C = -\\frac{1}{f_3} - \\frac{1}{f_2} - \\frac{1}{f_1} + \\frac{d_{12}}{f_1f_2} + \\frac{d_{23}}{f_2f_3} + \\frac{d_{12}d_{23}}{f_1f_2f_3}\\]\nThe magnification (A element) of the system is:\n\\[A = 1 - \\frac{d_{12}}{f_1} - \\frac{d_{23}}{f_2} + \\frac{d_{12}d_{23}}{f_1f_2}\\]\nFor perfect cloaking, we need both C = 0 and A = 1. From A = 1, we can derive:\n\\[\\frac{d_{12}}{f_1} + \\frac{d_{23}}{f_2} - \\frac{d_{12}d_{23}}{f_1f_2} = 0\\]\nSolving for \\(d_{23}\\), we get:\n\\[d_{23} = \\frac{d_{12}/f_1}{1/f_2 - d_{12}/(f_1f_2)}\\]\nSubstituting this into the condition for C = 0, we obtain a complex expression that places constraints on the possible values of \\(f_1\\), \\(f_2\\), and \\(f_3\\). For typical lens configurations, this results in values that are difficult to realize physically, as it often requires either negative separations or negative focal lengths.\nWhile the three-lens system provides more parameters to work with than the two-lens system, the mathematical constraints of simultaneously achieving zero focusing power (C = 0) and unit magnification (A = 1) still make perfect cloaking challenging with conventional optical elements.\n4. Four-Lens Configuration: The Solution\nWe can arrange four lenses in two pairs:\n\nFirst pair (lenses 1 and 2): A beam compressor\nSecond pair (lenses 3 and 4): A beam expander\n\nFor the beam compressor, with lenses at their combined focal length apart:\n\\[\n\\mathbf{M}_{comp} = \\left[\\begin{array}{cc}\n-\\frac{f_1}{f_2} & 0 \\\\\n0 & -\\frac{f_2}{f_1}\n\\end{array}\\right]\n\\]\nSimilarly, for the beam expander:\n\\[\n\\mathbf{M}_{exp} = \\left[\\begin{array}{cc}\n-\\frac{f_3}{f_4} & 0 \\\\\n0 & -\\frac{f_4}{f_3}\n\\end{array}\\right]\n\\]\nThe combined system matrix is:\n\\[\n\\mathbf{M}_{total} = \\mathbf{M}_{exp} \\times \\mathbf{M}_{comp} = \\left[\\begin{array}{cc}\n\\frac{f_1}{f_2} \\times \\frac{f_3}{f_4} & 0 \\\\\n0 & \\frac{f_2}{f_1} \\times \\frac{f_4}{f_3}\n\\end{array}\\right]\n\\]\nFor perfect cloaking, we need: - \\(\\frac{f_1}{f_2} \\times \\frac{f_3}{f_4} = 1\\) - \\(\\frac{f_2}{f_1} \\times \\frac{f_4}{f_3} = 1\\)\nThis is satisfied when \\(f_1 = f_4\\) and \\(f_2 = f_3\\).\nWith the lenses properly spaced and an additional free space distance \\(d_0\\) between the two pairs, the complete system matrix becomes:\n\\[\n\\mathbf{M}_{cloaking} = \\left[\\begin{array}{cc}\n1 & d_0 \\\\\n0 & 1\n\\end{array}\\right]\n\\]\nWhich perfectly mimics free space propagation, creating the optical cloaking effect.\n\n\nCode\n# Example of optical cloaking with four lenses using raytracing\nfrom raytracing import *\n\n# Define focal lengths (in mm)\nf1 = 200\nf2 = 75\nf3 = f2  # f3 = f2 = 75\nf4 = f1  # f4 = f1 = 200\n\n# Create an optical path\npath = ImagingPath()\n\n# Add the four lenses with proper spacing\npath.append(Space(d=100))  # Initial space before first lens\npath.append(Lens(f=f1, label=f\"f₁={f1}mm\"))\npath.append(Space(d=f1+f2))  # Distance between lens 1 and 2\npath.append(Lens(f=f2, label=f\"f₂={f2}mm\"))\npath.append(Space(d=100))  # Distance between lens pairs (d₀)\npath.append(Lens(f=f3, label=f\"f₃={f3}mm\"))\npath.append(Space(d=f3+f4))  # Distance between lens 3 and 4\npath.append(Lens(f=f4, label=f\"f₄={f4}mm\"))\npath.append(Space(d=100))  # Final space after last lens\n\n# Display the ray path with custom figure size\n\npath.display(raysList=[\n    [Ray(y=5, theta=0)],\n    [Ray(y=-5, theta=0)]\n], interactive=False)\n\n\nBeginnerHint [in figure.py]: Infinite field of view: cannot use limitObjectToFieldOfView=True. The object height is instead set to the default value of 10.0.\nBeginnerHint [in imagingpath.py]: Field of view is infinite. You can pass useObject=True to use the finite objectHeight.\nBeginnerHint [in figure.py]: No aperture stop in the system: cannot use onlyPrincipalAndAxialRays=True since they are not defined. Showing the default ObjectRays instead. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMultifocal Imaging\nWe would like to explore the concept of multifocal imaging to obtain 3D resolution from a single image. In a microscope, an objective lens together with a tube lens is used to focus light from a sample onto a detector. Either the tube lens is no modified to shift the focal plane of the objective lens or one uses multiple tube lenses with different focal lengths with a single objective lens.\n\n\n\n\n\n\nFigure 3— The multifocal adapter. (a) Composition of the multifocal imaging setup. The multifocal adapter (MFA) is inserted into the light path between a standard dark-field microscope and a camera. (b) Composition of the multifocal adapter. Incoming light from the microscope is infinity projected by the lens f1 and split by three consecutive beam-splitters (b1 = 25/75; b2 = 33/67; b3 = 50/50). Five mirrors (m) guide the light into four separate optical paths. The lens f5 projects the four images onto the camera chip. The inter-plane distance is set by lenses of different focal length (f1 - f4). (c, d) Experimentally acquired (c) and simulated (d) (see Methods) multifocal dark-field images (planes 1 - 4, 20x objective) of a calibration grid at the four focal positions (indicated on the left side), where one of the four focal planes maps the grid sharply. Scale bar represents 20 µm. Experiment was performed six times with similar results. Source\n\n\n\nIn the simplest configuration of an objective lens and a tube lens, the light first travels from the object to the objective lens in free space for a distance \\(s\\), which is represented by\n\n\n\\[\nM_1=\\left[\\begin{matrix}1 & s\\\\0 & 1\\end{matrix}\\right]\n\\]\n\n\nThen it is passing the objective lens with\n\n\n\\[\nM_2=\\left[\\begin{matrix}1 & 0\\\\- \\frac{1}{f_{1}} & 1\\end{matrix}\\right]\n\\]\n\n\ntraveling further through free space with distance \\(d\\)\n\n\n\\[\nM_3=\\left[\\begin{matrix}1 & d\\\\0 & 1\\end{matrix}\\right]\n\\]\n\n\nand then hitting the tube lens with\n\n\n\\[\nM_4=\\left[\\begin{matrix}1 & 0\\\\- \\frac{1}{\\Delta_{ft} + f_{t}} & 1\\end{matrix}\\right]\n\\]\n\n\nwhere \\(\\Delta_ft\\) is a parameter modifying the original tube lens focal distance \\(f_t\\). Finally, the light will propagate to the detector at distance \\(f_t\\) from the tube lens\n\n\n\\[\nM_s=\\left[\\begin{matrix}1 & f_{t}\\\\0 & 1\\end{matrix}\\right]\n\\]\n\n\ngicing for the whole system:\n\\[\nM_t=M_4 M_3 M_2 M_1\n\\]\nThe final matrix has again 4 parameters \\(A,B,C\\) and \\(D\\). For sharp imaging the parameter \\(B\\) of the system must be equal to zero, as the outgoing light should be independent of the incoming angle. This is achieved\n\n\n\\[\\delta s=\\frac{f_{1} \\left(\\Delta_{ft} d + \\Delta_{ft} f_{t} + f_{t}^{2}\\right)}{\\Delta_{ft} d - \\Delta_{ft} f_{1} + \\Delta_{ft} f_{t} + f_{t}^{2}}-s_0\n\\]\n\n\n\n\n\n\n\n\n\n\nFigure 4— Plot of the solution with specific parameter values\n\n\n\n\n\n\n\n\n\n\n\nThe B Parameter\n\n\n\n\n\nThe B parameter is the most direct indicator of a sharp image in matrix optics. For an optical system with ABCD matrix: \\[\n\\begin{pmatrix} y_2 \\\\ \\theta_2 \\end{pmatrix} =\n\\begin{pmatrix} A & B \\\\ C & D \\end{pmatrix}\n\\begin{pmatrix} y_1 \\\\ \\theta_1 \\end{pmatrix}\n\\]\nThe output position is given by: \\[y_2 = Ay_1 + B\\theta_1\\]\nFor an image to be sharp, all rays originating from the same object point must converge to a single image point, regardless of their initial angles. This means that for a given \\(y_1\\) (object position), the final position \\(y_2\\) must be independent of the initial angle \\(\\theta_1\\).\nThis condition is satisfied when B = 0.\nWhen B = 0: - The final position depends only on the initial position (\\(y_2 = Ay_1\\)) - All rays from a point source converge to a single point in the image plane - The imaging is “stigmatic” (point-to-point mapping)\nIn our lens example, the system matrix was: \\[\n\\mathbf{M}_{system} =\n\\left[\\begin{array}{cc}\n1-\\frac{d}{f} & d \\\\\n-\\frac{1}{f} & 1\n\\end{array}\\right]\n\\]\nFor parallel input rays (different \\(y_1\\) but all \\(\\theta_1 = 0\\)), we needed A = 0 to make them all converge to a single point, which happened when d = f.\nBut for general imaging of points (not just parallel rays), the B = 0 condition is what determines whether the image is sharp. This is why, in optical design, finding conjugate planes (where B = 0) is essential for sharp imaging.",
    "crumbs": [
      "Home",
      "FOUNDATIONS OF PHOTONICS",
      "Lecture 2",
      "Matrix Optics"
    ]
  },
  {
    "objectID": "lectures/lecture02/03-lecture02.html",
    "href": "lectures/lecture02/03-lecture02.html",
    "title": "Interference in space and time",
    "section": "",
    "text": "Interference is a fundamental physical phenomenon that demonstrates the superposition principle for linear systems. This principle, which states that the net response to multiple stimuli is the sum of the individual responses, is central to our understanding of wave physics. Interference appears across many domains of physics: in optics where it enables high-precision measurements and holography, in quantum mechanics where it reveals the wave nature of matter, and in acoustics where it forms the basis for noise cancellation technology. The ability of waves to interfere constructively (amplifying each other) or destructively (canceling each other) has profound practical applications, from the anti-reflective coatings on optical elements to the operational principles of interferometric gravitational wave detectors like LIGO. Understanding interference is therefore not just of theoretical interest but crucial for modern technology and experimental physics.\nWhen two wave solutions \\(U_1(\\mathbf{r})\\) and \\(U_2(\\mathbf{r})\\) combine, their superposition gives:\n\\[\nU(\\mathbf{r})=U_1(\\mathbf{r})+U_2(\\mathbf{r})\n\\]\nThe resulting intensity is:\n\\[\\begin{eqnarray}\nI &= &|U|^2\\\\\n&= &|U_1+U_2|^2\\\\\n&= &|U_1|^2+|U_2|^2+U^{*}_1 U_2 + U_1 U^{*}_2\n\\end{eqnarray}\\]\nThe individual wave intensities are given by \\(I_1=|U_1|^2\\) and \\(I_2=|U_2|^2\\). Using this, we can express each complex wave amplitude in polar form, separating its magnitude (related to intensity) and phase:\n\\[\nU_1=\\sqrt{I_1}e^{i\\phi_1}\n\\] \\[\nU_2=\\sqrt{I_2}e^{i\\phi_2}\n\\]\nSubstituting these expressions back into our interference equation and performing the algebra, the total intensity becomes:\n\\[\nI=I_1+I_2+2\\sqrt{I_1 I_2}\\cos(\\Delta \\phi)\n\\]\nwhere \\(\\Delta \\phi=\\phi_2-\\phi_1\\) is the phase difference between the waves. This equation is known as the interference formula and contains three terms:\n\n\\(I_1\\) and \\(I_2\\): the individual intensities\n\\(2\\sqrt{I_1 I_2}\\cos(\\Delta \\phi)\\): the interference term that can be positive or negative\n\nA particularly important special case occurs when the interfering waves have equal intensities (\\(I_1=I_2=I_0\\)). The equation then simplifies to:\n\\[\nI=2I_0(1+\\cos(\\Delta \\phi))=4I_0\\cos^2\\left(\\frac{\\Delta \\phi}{2}\\right)\n\\]\nThis last form clearly shows that:\n\nMaximum intensity (\\(4I_0\\)) occurs when \\(\\Delta \\phi = 2\\pi n\\) (constructive interference)\nZero intensity occurs when \\(\\Delta \\phi = (2n+1)\\pi\\) (destructive interference)\nThe intensity varies sinusoidally with the phase difference\n\n\n\n\n\n\n\nConstructive Interference\n\n\n\nOccurs when \\(\\Delta \\phi=2\\pi m\\) (where \\(m\\) is an integer), resulting in \\(I=4I_0\\)\n\n\n\n\nCode\nx=np.linspace(0,2,1000)\nwavelength=0.532\nk=2*np.pi/0.532\ny1=np.cos(k*x)\n\nfig,[ax1,ax2,ax3]=plt.subplots(3,1,figsize=get_size(10,8))\nax1.plot(x/wavelength,y1,label='Wave 1')\nax2.plot(x/wavelength,y1,label='Wave 1')\nax3.plot(x/wavelength,2*y1,label='Wave 1')\nax3.set_xlabel(r\"distance [$\\lambda$]\")\nax1.set_ylabel(r\"$U_1$\")\nax2.set_ylabel(r\"$U_2$\")\nax3.set_ylabel(r\"$U_1+U_2$\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\nConstructive interference of two waves (top, middle) and the sum of the two wave amplitudes (bottom)\n\n\n\n\n\n\n\n\n\n\nDestructive Interference\n\n\n\nOccurs when \\(\\Delta \\phi=(2m-1)\\pi\\) (where \\(m\\) is an integer), resulting in \\(I=0\\)\n\n\n\n\nCode\nx=np.linspace(0,2,1000)\nwavelength=0.532\nk=2*np.pi/0.532\ny1=np.cos(k*x)\ny2=np.cos(k*x+np.pi)\n\nfig,[ax1,ax2,ax3]=plt.subplots(3,1,figsize=get_size(10,8))\nax1.plot(x/wavelength,y1,label='Wave 1')\nax2.plot(x/wavelength,y2,label='Wave 1')\nax3.plot(x/wavelength,y1+y2,label='Wave 1')\nax3.set_xlabel(r\"distance [$\\lambda$]\")\nax1.set_ylabel(r\"$U_1$\")\nax2.set_ylabel(r\"$U_2$\")\nax3.set_ylabel(r\"$U_1+U_2$\")\nax3.set_ylim(-1,1)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\nDestructive interference of two waves (top, middle) and the sum of the two wave amplitudes (bottom)\n\n\n\n\n\nPhase and Path Difference\nThe phase difference \\(\\Delta \\phi\\) can be related to the path difference \\(\\Delta s\\) between the two waves. For two waves with the same frequency \\(\\omega\\), we can write their complete phase expressions as:\n\\[\\phi_1(\\mathbf{r},t) = \\mathbf{k}_1\\cdot\\mathbf{r} - \\omega t + \\phi_{01}\\] \\[\\phi_2(\\mathbf{r},t) = \\mathbf{k}_2\\cdot\\mathbf{r} - \\omega t + \\phi_{02}\\]\nwhere:\n\n\\(\\mathbf{k}_i\\) are the wave vectors\n\\(\\mathbf{r}\\) is the position vector\n\\(\\omega\\) is the angular frequency\n\\(\\phi_{0i}\\) are initial phase constants\n\nThe instantaneous phase difference is then:\n\\[\n\\Delta\\phi(\\mathbf{r},t) = \\phi_2(\\mathbf{r},t) - \\phi_1(\\mathbf{r},t) = (\\mathbf{k}_2-\\mathbf{k}_1)\\cdot\\mathbf{r} + (\\phi_{02}-\\phi_{01})\n\\]\nFor stationary interference patterns, we typically observe the time-independent phase difference. When the waves travel along similar paths (same direction), this reduces to:\n\\[\\Delta\\phi = k\\Delta s + \\Delta\\phi_0\\]\nwhere \\(\\Delta s\\) is the path difference and \\(\\Delta\\phi_0\\) is any initial phase difference between the sources.\n\n\n\n\n\n\nPhase Difference and Path Difference\n\n\n\nA path difference \\(\\Delta s\\) corresponds to a phase difference \\(k\\Delta s=2\\pi\\Delta s/\\lambda\\). Path differences of integer multiples of \\(\\lambda\\) result in phase differences of integer multiples of \\(2\\pi\\).\n\n\n\n\nInterference of Waves in Space\n\n\nCode\ndef plane_wave(k,omega,r,t):\n    return(np.exp(1j*(np.dot(k,r)-omega*t)))\n\nwavelength=532e-9\nk0=2*np.pi/wavelength\nc=299792458\nomega0=k0*c\n\nvec=np.array([0.0,0.,1.])\nvec1=np.array([1.0,0.,1.])\nvec=vec/np.sqrt(np.dot(vec,vec))\nvec1=vec1/np.sqrt(np.dot(vec1,vec1))\n\nk=k0*vec\nk1=k0*vec1\n\nx=np.linspace(-2.5e-6,2.5e-6,300)\nz=np.linspace(0,5e-6,300)\n\nX,Z=np.meshgrid(x,z)\nr=np.array([X,0,Z],dtype=object)\n\nfig,ax=plt.subplots(2,2,figsize=get_size(10,10))\nfield=plane_wave(k,omega0,r,0)\nfield1=plane_wave(k1,omega0,r,0)\n\nextent = np.min(z)*1e6, np.max(z)*1e6,np.min(x)*1e6, np.max(x)*1e6\nax[0,0].imshow(np.real(field.transpose()),extent=extent,vmin=-1,vmax=1,cmap='seismic')\nax[0,0].set_title('wave 1')\nax[0,1].imshow(np.real(field1.transpose()),extent=extent,vmin=-1,vmax=1,cmap='seismic')\nax[0,1].set_title('wave 2')\nax[1,0].imshow(np.real(field.transpose()+field1.transpose()),extent=extent,vmin=-1,vmax=1,cmap='seismic')\nax[1,0].set_title('sum')\nax[1,1].imshow(np.abs(field.transpose()+field1.transpose())**2,extent=extent,cmap='gray')\nax[1,1].set_title('intensity')\nax[1,1].set_xlabel('z-position [µm]')\nax[1,0].set_xlabel('z-position [µm]')\nax[1,0].set_ylabel('x-position [µm]')\nax[0,0].set_ylabel('x-position [µm]')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\nInterference of two plane waves propagating under an angle of 45°. The two left graphs show the original waves. The two right show the total amplitude and the intensity pattern.\n\n\n\n\n\n\nCode\ndef spherical_wave(k,omega,r,r0,t):\n    k=np.linalg.norm(k)\n    d=np.linalg.norm(r-r0)\n    return( np.exp(1j*(k*d-omega*t))/d)\n\n\n\nx=np.linspace(-5e-6,5e-6,300)\nz=np.linspace(-5e-6,5e-6,300)\n\nX,Z=np.meshgrid(x,z)\nr=np.array([X,0,Z],dtype=object)\n\nwavelength=532e-9\nk0=2*np.pi/wavelength\nc=299792458\nomega0=k0*c\n\nk=k0*np.array([0,1.0,0])\nr0=np.array([0,2e-6,0])\n\nfield=spherical_wave(k,omega0,r,r0,0)\nfield1=plane_wave(k,omega0,r,0)\n\nextent = np.min(z)*1e6, np.max(z)*1e6,np.min(x)*1e6, np.max(x)*1e6\n\nfig,ax=plt.subplots(2,2,figsize=get_size(10,10))\nax[0,0].imshow(np.real(field.transpose()+0*field1.transpose()),extent=extent,cmap='seismic')\nax[0,0].set_title('Spherical wave')\nax[0,1].imshow(np.real(0*field.transpose()+field1.transpose()),extent=extent,cmap='seismic')\nax[0,1].set_title('Plane wave')\nax[1,0].imshow(np.real(0.00001*field.transpose()+field1.transpose()),extent=extent,cmap='seismic')\nax[0,1].set_title('Sum')\nax[1,1].imshow(np.abs(0.00001*field.transpose()+field1.transpose())**2,extent=extent,cmap='gray')\nax[0,1].set_title('Intensity')\nax[1,0].set_xlabel('z [µm]')\nax[1,1].set_xlabel('z [µm]')\nax[1,0].set_ylabel('x [µm]')\nax[0,0].set_ylabel('x [µm]')\nplt.show()\n\n\n\n\n\nInterference of a spherical wave and a plane wave. The top graphs show the original waves. The two bottom show the total amplitude and the intensity pattern.\n\n\n\n\nThe interference of the spherical and the plane wave (also the one of the two plane waves) give also an interesting result. The intensity resembles to be a snapshot of the shape of the wavefronts of the spherical wave. We can therefore measure the wavefronts of the spherical wave by interfering it with a plane wave. This is also the basic principle behind holography. There we use a reference wave to interfere with the wave that we want to measure. The interference pattern is recorded and can be used to reconstruct the wavefronts of the wave.\n\nA super nice website to try out interference interactively is here.\n\n\n\nCoherence\nIn the earlier consideration we obtained a general description for the phase difference between two waves. TIt is given by and contains the pathlength difference \\(\\Delta s\\) and some intrinsic phase \\(\\Delta\\phi_0\\) that could be part of the wave generation process.\n\\[\\Delta\\phi = k\\Delta s + \\Delta\\phi_0\\]\nTo observe stationary interference, it is important that these two quantities are also stationary, i.e. the phase relation between the two waves is stationary. This relation between the phase of two waves is called coherence and was assumed in all the examples before.\n\n\n\nTwo waves of different frequency over time.\n\n\nThe above image shows the timetrace of the amplitude of two wave with slightly different frequency. Due to the frequency, the waves run out of phase and have acquired a phase different of \\(\\pi\\) after \\(40\\) fs.\nThe temporal coherence of two waves is now defined by the time it takes for the two waves to obtain a phase difference of \\(2\\pi\\). The phase difference between two wave of frequency \\(\\nu_1\\) and \\(\\nu_2\\) is given by\n\\[\n\\Delta \\phi = 2\\pi (\\nu_2-\\nu_1)(t-t_0)\n\\]\nHere \\(t_0\\) refers to the time, when thw two waves were perfectly in sync. Lets assume that the two frequencies are seperarated from a central frequency \\(\\nu_0\\) such that\n\\[\n\\nu_1=\\nu_0-\\Delta \\nu/2\n\\] \\[\n\\nu_2=\\nu_0+\\Delta \\nu/2\n\\]\nInserting this into the first equation yields\n\\[\n\\Delta \\phi = 2\\pi \\Delta \\nu \\Delta t\n\\]\nwith \\(\\Delta t=t-t_0\\). We can now define the coherence time as the time interval over which the phase shift \\(\\Delta \\phi\\) grows to \\(2\\pi\\), i.e. \\(\\Delta \\phi=2\\pi\\). The coherence time is thus\n\\[\n\\tau_{c}=\\Delta t =\\frac{1}{\\Delta \\nu}\n\\]\nThus the temporal coherence and the frequency distribution of the light are intrisincly connected. Monochromatic light has \\(\\Delta nu=0\\) and thus the coherence time is infinitely long. Light with a wide spectrum (white light for example) therefore has and extremly short coherence time.\nThe coherence time is also connected to a coherence length. The coherence length \\(L_c\\) is given by the distance light travels within the coherence time \\(\\tau_c\\), i.e.\n\\[\nL_c=c\\tau_c\n\\]\n\n\n\n\n\n\nCoherence\n\n\n\nTwo waves are called coherent, if they exihibit a fixed phase relation in space or time relation over time. It measures their ability to interfer. The main types of coherence are\n\nTemporal Coherence\n\nMeasures phase correlation of a wave with itself at different times\nCharacterized by coherence time \\(\\tau_c\\) and coherence length \\(L_c = c\\tau_c\\)\nRelated to spectral width: \\(\\tau_c = 1/\\Delta\\nu\\)\nPerfect for monochromatic waves (single frequency)\nLimited for broad spectrum sources (like thermal light)\n\n\n\nSpatial Coherence\n\nMeasures phase correlation between different points in space\nImportant for interference from extended sources\nDetermines ability to form interference patterns\nRelated to source size and geometry\n\nCoherence is a property of the light source and is connected to the frequency distribution of the light. Sources can be:\n\nFully coherent: ideal laser\nPartially coherent: real laser\nIncoherent: thermal light\n\n\n\n\n\n\n\n\n\n\nMore General Description of Coherence\n\n\n\n\n\nWhile the above definition provides an intuitive picture based on frequency spread, we can describe coherence more rigorously using correlation functions. These functions measure how well a wave maintains its phase relationships:\nIn real physical systems, perfect coherence (constant phase relationship) between waves is rare. Partial coherence describes the degree to which waves maintain a consistent phase relationship over time and space. We can characterize this using correlation functions:\n\nTemporal Coherence The complex degree of temporal coherence is given by:\n\n\\[g^{(1)}(\\tau) = \\frac{\\langle U(t)U^*(t+\\tau)\\rangle}{\\sqrt{\\langle|U(t)|^2\\rangle\\langle|U(t+\\tau)|^2\\rangle}}\\]\nwhere:\n\n\\(\\tau\\) is the time delay\n\\(U(t)\\) is the electric field\n\\(\\langle...\\rangle\\) denotes time averaging\n\n\nSpatial Coherence Similarly, spatial coherence between two points is characterized by:\n\n\\[g^{(1)}(\\mathbf{r}_1,\\mathbf{r}_2) = \\frac{\\langle U(\\mathbf{r}_1)U^*(\\mathbf{r}_2)\\rangle}{\\sqrt{\\langle|U(\\mathbf{r}_1)|^2\\rangle\\langle|U(\\mathbf{r}_2)|^2\\rangle}}\\]\nThe obtained correlation functions can be used to calculate the coherence time and length and have the following properties:\n\n\\(|g^{(1)}| = 1\\) indicates perfect coherence\n\\(|g^{(1)}| = 0\\) indicates complete incoherence\n\\(0 &lt; |g^{(1)}| &lt; 1\\) indicates partial coherence\n\nA finite coherence time and length is leads to partial coherence affects interference visibility through:\n\nReduced contrast in interference patterns\nLimited coherence length/area\nSpectral broadening\n\n\n\nCode\nomega0 = 2.0\ndelta_omega = 0.05  # frequency difference\ntau_c = np.pi/delta_omega  # coherence time (corrected)\nbeat_period = 2*np.pi/delta_omega  # time for full beat cycle\n\nt = np.linspace(0, 1000, 10000)\ntau = np.linspace(0, 500, 200)\n\ndef generate_waves(t):\n    wave1 = np.exp(1j * omega0 * t)\n    wave2 = np.exp(1j * (omega0 + delta_omega) * t)\n    return wave1, wave2\n\ndef calc_correlation(wave, tau):\n    g = np.zeros(len(tau), dtype=complex)\n    N = len(wave)\n\n    for i, dt in enumerate(tau):\n        shift = int(dt * 10)\n        if shift &gt;= N:\n            g[i] = 0\n        else:\n            g[i] = np.mean(wave[:(N-shift)] * np.conj(wave[shift:]))\n\n    return g / np.abs(g[0])\n\n\nwave1, wave2 = generate_waves(t)\nwave_total = wave1 + wave2\n\n# Calculate correlation\ng = calc_correlation(wave_total, tau)\n\n# Plot\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=get_size(10, 8))\n\n# Plot waves\nax1.plot(t[:500], np.real(wave1[:500]), label='Wave 1', alpha=0.7)\nax1.plot(t[:500], np.real(wave2[:500]), label='Wave 2', alpha=0.7)\nax1.plot(t[:500], np.real(wave_total[:500]), 'k', label='Sum', alpha=0.7,lw=0.5)\nax1.set_title('wave superposition')\nax1.set_xlabel('time')\nax1.set_ylabel('amplitude')\nax1.legend(bbox_to_anchor=(1.05, 1), loc='upper left')\n\n\n# Plot correlation\nax2.plot(tau, np.abs(g))\nax2.axvline(x=tau_c, color='r', linestyle='--', label=r'$\\tau_c$ ')\nax2.axvline(x=beat_period, color='g', linestyle=':', label=f'Beat period')\nax2.set_title('|g⁽¹⁾(τ)|')\nax2.set_xlabel('τ')\nax2.set_ylabel('|g⁽¹⁾(τ)|')\nax2.legend(bbox_to_anchor=(1.05, 1), loc='upper left')\nplt.tight_layout()\nplt.subplots_adjust(right=0.85)\n\nplt.show()\n\n\n\n\n\nTemporal correlation for two waves with slightly different frequencies. The vertical line indicates the coherence time τc = π/Δω.\n\n\n\n\nBesides different frequencies the coherence time can also be affected by phase jumps. The following example shows two waves with the same frequency but multiple phase jumps. The temporal correlation function shows the decoherence due to the phase jumps.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nomega0 = 1.0  # same frequency for both waves\ntau = np.linspace(0, 500, 200)\n\nt = np.linspace(0, 1000, 10000)\n\ndef generate_waves_with_jumps(t, n_jumps=10):\n    # Create two identical waves\n    wave1 = np.exp(1j * omega0 * t)\n    wave2 = np.exp(1j * omega0 * t)  # same frequency\n\n    # Create regularly spaced jumps within first 500 time units\n    jump_positions = np.linspace(0, 500, n_jumps+1)[:-1]  # exclude last point\n    jump_indices = [int(pos * len(t)/t[-1]) for pos in jump_positions]\n    phase_shifts = np.random.uniform(0, 2*np.pi, n_jumps)\n\n    # Apply phase shifts to wave2\n    wave2_with_jumps = wave2.copy()\n    current_phase = 0\n\n    for i in range(n_jumps):\n        start_idx = jump_indices[i]\n        if i &lt; n_jumps-1:\n            end_idx = jump_indices[i+1]\n        else:\n            end_idx = len(t)\n\n        current_phase += phase_shifts[i]\n        wave2_with_jumps[start_idx:end_idx] *= np.exp(1j * current_phase)\n\n    return wave1, wave2_with_jumps, jump_positions\n\n\ndef calc_correlation(wave, tau):\n    g = np.zeros(len(tau), dtype=complex)\n    N = len(wave)\n\n    for i, dt in enumerate(tau):\n        shift = int(dt * 10)\n        if shift &gt;= N:\n            g[i] = 0\n        else:\n            g[i] = np.mean(wave[:(N-shift)] * np.conj(wave[shift:]))\n\n    return g / np.abs(g[0])\n\n# Generate waves with 30 jumps\nwave1, wave2, jump_positions = generate_waves_with_jumps(t, n_jumps=30)\nwave_total = wave1 + wave2\n\ng = calc_correlation(wave_total, tau)\n\n\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=get_size(10, 8))\n\nax1.plot(t[:2000], np.real(wave1[:2000]), label='Wave 1', alpha=0.9)\nax1.plot(t[:2000], np.real(wave2[:2000]), label='Wave 2', alpha=0.9)\nax1.plot(t[:2000], np.real(wave_total[:2000]), 'k-', label='Sum', lw=0.5)\nax1.set_xlim(0, 200)\n# Add vertical lines for phase jumps in wave plot\nfor pos in jump_positions:\n    ax1.axvline(x=pos, color='r', linestyle='--', alpha=0.3)\n\nax1.set_title('Superposition with Multiple Phase Jumps')\nax1.set_xlabel('time')\nax1.set_ylabel('amplitude')\nax1.legend(bbox_to_anchor=(1.05, 1), loc='upper left')\n\n# Plot correlation\nax2.plot(tau, np.abs(g))\n\nax2.set_title('|g⁽¹⁾(τ)|')\nax2.set_xlabel('τ')\nax2.set_ylabel('|g⁽¹⁾(τ)|')\nax2.set_xlim(0, 200)\nax2.set_ylim(0, 1)\n\n# Adjust layout\nplt.tight_layout()\nplt.subplots_adjust(right=0.85)\n\nplt.show()\n\n\n\n\n\nTemporal correlation for two waves of same frequency showing decoherence due to multiple phase jumps. Vertical lines indicate positions of phase jumps.\n\n\n\n\n\n\n\nMultiple Wave Interference\nSo far we looked at the interference of two waves, which was a simplification as I mentioned already earlier. Commonly there will be a multitude of partial waves contribute to the oberved intereference. This is what we would like to have a look at now. We will do that in a quite general fashion, as the resulting formulas will appear several times again for different problems.\nNevertheless we will make a difference between\n\nmultiwave interference of waves with the constant amplitude\nmultiwave interference of waves with decreasing amplitude\n\nEspecially the latter is often occuring, if we have multiple reflections and each reflection is only a fraction of the incident amplitude.\n\n\nMultiple Wave Interference with Constant Amplitude\nIn the case of constant amplitude (for example realized by a grating, which we talk about later), the total wave amplitude is given according to the picture below by\n\\[\nU=U_1+U_2+U_1+U_3+\\ldots+U_M\n\\]\nwhere we sum the amplitude over \\(M\\) partial waves. Between the neighboring waves (e.g. \\(U_1\\) and \\(U_2\\)), we will assume a phase difference (because of a path length difference for example), which we denote as \\(\\Delta \\phi\\).\nThe amplitude of the p-th wave is then given by\n\\[\nU_p=\\sqrt{I_0}e^{i(p-1)\\Delta \\phi}\n\\]\nwith the index \\(p\\) being an interger \\(p=1,2,\\ldots,M\\), \\(h=e^{i\\Delta \\phi}\\) and \\(\\sqrt{I_0}\\) as the amplitude of each individual wave. The total amplitude \\(U\\) can be then expressed as\n\\[\nU=\\sqrt{I_0}\\left (1+h+h^2+\\ldots +h^{M-1}\\right)\n\\]\nwhich is a geometric sum. We can apply the sum formula for geometric sums to obtain\n\\[\nU=\\sqrt{I_0}\\frac{1-h^M}{1-h}=\\sqrt{I_0}\\frac{1-e^{iM\\Delta \\phi}}{1-e^{i\\Delta \\phi}}\n\\]\nWe now have to calculate the intensity of the total amplitude\n\\[\nI=|U|^2=I_{0}\\left | \\frac{e^{-iM\\Delta \\phi/2}-e^{iM\\Delta \\phi/2}}{e^{-i\\Delta \\phi/2}-e^{i\\Delta \\phi/2}}\\right |^2\n\\]\nwhich we can further simplify to give\n\\[\nI=I_{0}\\frac{\\sin^2(M\\Delta \\phi/2)}{\\sin^2(\\Delta \\phi/2)}\n\\]\n\nCode\n# Parameters\nM = 6  # number of phasors\nphi = np.pi/8  # example phase difference between successive phasors\n\ndef plot_angle(ax, pos, angle, length=0.95, acol=\"C0\", **kwargs):\n    vec2 = np.array([np.cos(np.deg2rad(angle)), np.sin(np.deg2rad(angle))])\n    xy = np.c_[[length, 0], [0, 0], vec2*length].T + np.array(pos)\n    ax.plot(*xy.T, color=acol)\n    return AngleAnnotation(pos, xy[0], xy[2], ax=ax, **kwargs)\n\n# Calculate phasor positions\ndef calculate_phasors(phi, M):\n    # Initialize arrays for arrow start and end points\n    x_start = np.zeros(M)\n    y_start = np.zeros(M)\n    x_end = np.zeros(M)\n    y_end = np.zeros(M)\n\n    # Running sum of phasors\n    x_sum = 0\n    y_sum = 0\n\n    for i in range(M):\n        # Current phasor\n        x = np.cos(i * phi)\n        y = np.sin(i * phi)\n\n        # Store start point (end of previous phasor)\n        x_start[i] = x_sum\n        y_start[i] = y_sum\n\n        # Add current phasor\n        x_sum += x\n        y_sum += y\n\n        # Store end point\n        x_end[i] = x_sum\n        y_end[i] = y_sum\n\n    return x_start, y_start, x_end, y_end\n\nx_start, y_start, x_end, y_end = calculate_phasors(phi, M)\n\nplt.figure(figsize=get_size(6, 6))\nax = plt.gca()\n\nfor i in range(M):\n    plt.arrow(x_start[i], y_start[i],\n             x_end[i]-x_start[i], y_end[i]-y_start[i],\n             head_width=0.15, head_length=0.2, fc='k', ec='k',\n             length_includes_head=True,\n             label=f'E{i+1}' if i == 0 else \"\")\n\nplt.arrow(0, 0, x_end[-1], y_end[-1],\n         head_width=0.15, head_length=0.2, fc='r', ec='r',\n         length_includes_head=True, label='Resultant')\n\nax.set_aspect('equal')\nxx = np.linspace(-1, 3, 100)\nax.plot(xx,(xx-1)*np.tan(phi),'k--',lw=0.5)\nax.plot([1,3],[0,0],'k--',lw=0.5)\nkw = dict(size=195, unit=\"points\", text=r\"$\\Delta \\phi$\")\nplot_angle(ax, (1.0, 0), phi*180/np.pi, textposition=\"inside\", **kw)\nplt.axis('off')\nmax_range = max(abs(x_end[-1]), abs(y_end[-1])) * 1.2\nplt.xlim(-0, max_range/1.5)\nplt.ylim(-0.1, max_range/1.)\n\nplt.show()\n# Parameters\nM = 6\nphi = np.linspace(-4*np.pi, 4*np.pi, 10000)  # increased resolution\nI0 = 1\n\ndef multiple_beam_pattern(phi, M):\n    numerator = np.sin(M * phi/2)**2\n    denominator = np.sin(phi/2)**2\n    I = np.where(denominator != 0, numerator/denominator, M**2)\n    return I\n\nI = I0 * multiple_beam_pattern(phi, M)\n\nfirst_min = 2*np.pi/M  # theoretical value\n\ndef find_nearest(array, value):\n    array = np.asarray(array)\n    idx = (np.abs(array - value)).argmin()\n    return array[idx], idx\n\nhalf_max = M**2/2\n\nphi_positive = phi[phi &gt;= 0]  # only positive values\nI_positive = I[phi &gt;= 0]\n_, idx_half = find_nearest(I_positive, half_max)\nhalf_width = phi_positive[idx_half]\n\n# Create plot\nplt.figure(figsize=get_size(10, 6))\nplt.plot(phi/np.pi, I, 'b-', label=f'M={M}')\n\n#plt.plot(first_min/np.pi, multiple_beam_pattern(first_min, M), 'ro')\n#plt.annotate(f'First minimum\\nφ = 2π/M = {first_min/np.pi:.2f}π',\n\nplt.axvline(x=first_min/np.pi, color='r', linestyle='--', label=f'φ = 2π/M = {first_min/np.pi:.2f}π')\n\n#plt.plot(half_width/np.pi, half_max, 'go')\n\nplt.xlabel(r'phase $\\Delta \\phi/\\pi$')\nplt.ylabel('intensity I/I₀')\nplt.title(f'Multiple Beam Interference Pattern (M={M})')\nplt.ylim(0, M**2 + 15)\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nMultiple wave interference of \\(M=6\\) waves with a phase difference of \\(\\phi=\\pi/8\\). The black arrows represent the individual waves, the red arrow the sum of all waves.\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1— Multiple beam interference pattern for M=6 beams. The intensity distribution is shown as a function of the phase shift \\(\\phi\\). The first minimum is at \\(\\phi=2\\pi/M\\). The intensity distribution is symmetric around \\(\\phi=0\\).\n\n\n\n\n\n\n\nThe result is therefore an oscillating function. The numerator \\(\\sin^2(M\\Delta \\phi/2)\\) shows and oscillation frequency, which is by a factor of \\(M\\) higher than the one in the denominator \\(\\sin^2 (\\Delta \\phi/2)\\). Therefore the intensity pattern is oscillating rapidly and creating a first minimum at\n\\[\n\\Delta \\phi=\\frac{2\\pi}{M}\n\\]\nThis is an important result, since it shows that the number of sources \\(M\\) determines the position of the first minimum and the interference peak gets narrower with increasing \\(M\\). Since the phase difference \\(\\Delta \\phi\\) between neighboring sources is the same as for the double slit experiment, i.e. \\(\\Delta \\phi=2\\pi d/\\lambda \\sin(\\theta)\\), we can also determine the angular position of the first minimum. This is given by\n\\[\n\\sin(\\theta_\\textrm{min})=\\frac{1}{M}\\frac{\\lambda}{d}\n\\]\nThis again has the common feature that it scales as \\(\\lambda/d\\). A special situation occurs, whenever the numerator and the denominator become zero. This will happen whenever\n\\[\n\\Delta \\phi=m 2\\pi\n\\]\nwhere \\(m\\) is an integer and denotes the interference order, i.e. the number of wavelength that neighboring partial waves have as path length difference. In this case, the intensity distributiion will give us\n\\[\nI=I_0 \\frac{0}{0}\n\\]\nand we have to determine the limit with the help of l’Hospitals rule. The outcome of this calculation is, that\n\\[\nI(\\Delta \\phi=m2\\Delta \\pi)=M^2 I_0\n\\]\nwhich can be also realized when using the small angle approximation for the sine functions.\n\nWavevector Representation\nWe would like to introduce a different representation of the multiple wave interference of the grating, which is quite insightful. The first order (\\(m=1\\)) constructive interference condition is given by\n\\[\n\\frac{1}{\\lambda}\\sin{\\theta}= \\frac{1}{d}\n\\]\nwhich also means that\n\\[\n\\frac{2\\pi}{\\lambda}\\sin{\\theta}= \\frac{2\\pi}{d}\n\\]\nThis can be written as\n\\[\nk \\sin{\\theta}= K\n\\]\nwhere \\(k\\) is the magnitude of the wavevector of the light and \\(K\\) is the wavevector magnitude that corresponds to the grating period \\(d\\). As the magnitude of the wavevector of the light is conserved, the wavevectors of the incident light and the light traveling along the direction of the first interence peak form the sides of an equilateral triangle. This is shown in the following figure.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\nk = 1  # Magnitude of k₁ and k₂\n\norigin = np.array([0, 0])\n\nk1 = np.array([k, 0])\n\ntheta_deg = 30  # θ = 30 degrees\ntheta_rad = np.deg2rad(theta_deg)\n\nk2 = k * np.array([np.cos(theta_rad), np.sin(theta_rad)])\n\nK = k2 - k1\n\npoint_O = origin\npoint_A = point_O + k1\npoint_B = point_O + k2\n\n\nplt.figure(figsize=get_size(10, 10))\nax = plt.gca()\n\n# Plot vector k₁\nax.arrow(point_O[0], point_O[1], k1[0], k1[1],\n         head_width=0.02, head_length=0.03, fc='k', ec='k', length_includes_head=True)\n\n\nax.arrow(point_A[0], point_A[1], K[0], K[1],\n         head_width=0.02, head_length=0.03, fc='b', ec='b', length_includes_head=True)\n\nax.arrow(point_O[0], point_O[1], k2[0], k2[1],\n         head_width=0.02, head_length=0.03, fc='k', ec='k', length_includes_head=True)\n\n# Label vectors\nax.text(k1[0]/2 - 0.05, k1[1]/2 - 0.05, r'$\\mathbf{k}$', fontsize=14, color='k')\nax.text(point_A[0] + K[0]/2 , point_A[1] + K[1]/2 + 0.05, r'$\\mathbf{K}$', fontsize=14, color='b')\nax.text(k2[0]/2 + 0.0, k2[1]/2+0.1, r'$\\mathbf{k}$', fontsize=14, color='k')\n\n# Indicate angle θ between k₁ and k₂ at the origin\narc_radius = 0.3  # Radius of the arc representing θ\nangle_range = np.linspace(0, theta_rad, 100)\narc_x = arc_radius * np.cos(angle_range)\narc_y = arc_radius * np.sin(angle_range)\nax.plot(arc_x, arc_y, color='k')\n\nax.text(arc_radius * np.cos(theta_rad / 2) + 0.02,\n        arc_radius * np.sin(theta_rad / 2) + 0.02,\n        r'$\\theta$', fontsize=14)\n\n# Set equal aspect ratio\nax.set_aspect('equal', adjustable='box')\n\nall_x = [point_O[0], point_A[0], point_B[0]]\nall_y = [point_O[1], point_A[1], point_B[1]]\nmargin = 0.2\nax.set_xlim(min(all_x) - margin, max(all_x) + margin)\nax.set_ylim(min(all_y) - margin, max(all_y) + margin)\nplt.axis('off')\n\n# Display the plot\nplt.show()\n\n\n\n\n\nWavevector summation for the diffraction grating. The wavevector of the incident light \\(k\\) and the wavevector of the light traveling along the direction of the first interference peak \\(K\\) form an equilateral triangle.\n\n\n\n\nThis means that the diffraction grating is providing a wavevector \\(K\\) to alter the direction of the incident light. This is again a common feature reappearing in many situations as for example in the X-ray diffraction of crystals.\n\n\n\n\n\n\nMultiple Wave Interference with Decreasing Amplitude\n\n\n\n\n\nWe will turn our attention now to a slight modification of the previous multiwave interference. We will introduce a decreasing amplitude of the individual waves. The first wave shall have an amplitude \\(U_1=\\sqrt{I_0}\\). The next wave, however, will not only be phase shifted but also have a smaller amplitude.\n\\[\nU_2=h U_1\n\\]\nwhere \\(h=re^{i\\phi}\\) with \\(|h|=r&lt;1\\). \\(r\\) can be regarded as a reflection coefficient, which deminishes the amplitude of the incident wave. According to that the intensity is reduced by\n\\[\nI_2=|U_2|^2=|h U_1|^2=r^2 I_1\n\\]\nThe intensity of the incident wave is multiplied by a factor \\(r^2\\), while the amplitude is multiplied by \\(r\\). Note that the phase factor \\(e^{i\\Delta\\phi}\\) is removed when taking the square of this complex number.\n\n\n\n\n\n\nIntensity at Boundaries\n\n\n\nThe amplitude of the reflected wave is diminished by a factor \\(r\\le 1\\), which is called the reflection coefficient. The intensity is diminished by a factor \\(R=|r|^2\\le1\\), which is the reflectance.\nIn the absence of absorption, reflectance \\(R\\) and transmittance \\(T\\) add to one due to energy conservation.\n\\[\nR+T=1\n\\]\n\n\nConsequently, the third wave would be now \\(U_3=hU_2=h^2U_1\\). The total amplitude is thus\n\\[\nU=U_1+U_2+U_3+\\ldots+U_M = \\sqrt{I_0}(1+h+h^2+\\ldots)\n\\]\n\n\n\nCode\nM = 18  # number of phasors\nphi = np.pi/6  # example phase difference between successive phasors\nr = 0.95  # reduction factor for each subsequent phasor\n\ndef plot_angle(ax, pos, angle, length=0.95, acol=\"C0\", **kwargs):\n    vec2 = np.array([np.cos(np.deg2rad(angle)), np.sin(np.deg2rad(angle))])\n    xy = np.c_[[length, 0], [0, 0], vec2*length].T + np.array(pos)\n    ax.plot(*xy.T, color=acol)\n    return AngleAnnotation(pos, xy[0], xy[2], ax=ax, **kwargs)\n\ndef calculate_phasors(phi, M, r):\n    x_start = np.zeros(M)\n    y_start = np.zeros(M)\n    x_end = np.zeros(M)\n    y_end = np.zeros(M)\n\n    x_sum = 0\n    y_sum = 0\n\n    for i in range(M):\n        amplitude = r**i  # exponential decrease\n        x = amplitude * np.cos(i * phi)\n        y = amplitude * np.sin(i * phi)\n\n        x_start[i] = x_sum\n        y_start[i] = y_sum\n\n        x_sum += x\n        y_sum += y\n\n        x_end[i] = x_sum\n        y_end[i] = y_sum\n\n    return x_start, y_start, x_end, y_end\n\nx_start, y_start, x_end, y_end = calculate_phasors(phi, M, r)\n\nplt.figure(figsize=get_size(6, 6),dpi=150)\nax = plt.gca()\n\nfor i in range(M):\n    plt.arrow(x_start[i], y_start[i],\n             x_end[i]-x_start[i], y_end[i]-y_start[i],\n             head_width=0.15, head_length=0.2,\n             fc='k', ec='k',\n             length_includes_head=True,\n             label=f'E{i+1}' if i == 0 else \"\")\n\nplt.arrow(0, 0, x_end[-1], y_end[-1],\n         head_width=0.15, head_length=0.2, fc='r', ec='r',\n         length_includes_head=True, label='Resultant')\n\nax.set_aspect('equal')\nxx = np.linspace(-1, 3, 100)\nax.plot(xx,(xx-1)*np.tan(phi),'k--',lw=0.5)\nax.plot([1,3],[0,0],'k--',lw=0.5)\nkw = dict(size=195, unit=\"points\", text=r\"$\\phi$\")\nplot_angle(ax, (1.0, 0), phi*180/np.pi, textposition=\"inside\", **kw)\nplt.axis('off')\nmax_range = max(abs(x_end[-1]), abs(y_end[-1])) * 1.2\nplt.xlim(-max_range/1.8, max_range/0.8)\nplt.ylim(-0.1, max_range/0.9)\n\nplt.show()\n\n\n\n\n\nPhase construction of a multiwave intereference with M waves with decreasing amplitude due to a reflection coefficient \\(r=0.95\\).\n\n\n\n\n\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Create phase array from -2π to 2π\nphi = np.linspace(-2*np.pi, 2*np.pi, 1000)\n\ndef calculate_intensity(phi, F):\n    return 1/(1 + 4*(F/np.pi)**2 * np.sin(phi/2)**2)\n\nplt.figure(figsize=get_size(10, 6))\n\nfinesse_values = [1, 4, 20]\nstyles = ['-', '--', ':']\n\nfor F, style in zip(finesse_values, styles):\n    I = calculate_intensity(phi, F)\n    plt.plot(phi/np.pi, I, style, label=f'$\\\\mathcal{{F}}={F}$')\n\nplt.xlabel('Phase $\\\\phi/\\\\pi$')\nplt.ylabel('$I/I_{\\\\mathrm{max}}$')\nplt.grid(True, alpha=0.3)\nplt.legend()\nplt.ylim(0, 1.1)\n\nplt.show()\n\n\n\n\n\nMultiple wave interference with decreasing amplitude. The graph shows the intensity distribution over the phase angle \\(\\phi\\) for different values of the Finesse \\(\\mathcal{F}\\).\n\n\n\n\n\nThis yields again\n\\[\nU=\\sqrt{I_0}\\frac{(1-h^M)}{1-h}=\\frac{\\sqrt{I_0}}{1-r e^{i\\Delta\\phi}}\n\\]\nCalculating the intensity of the waves is giving\n\\[\nI=|U|^2=\\frac{I_{0}}{|1-re^{i\\Delta\\phi}|^2}=\\frac{I_0}{(1-r)^2+4r\\sin^2(\\Delta\\phi/2)}\n\\]\nwhich is also known as the Airy function. This function can be further simplified by the following abbrevations\n\\[\nI_{\\rm max}=\\frac{I_0}{(1-r)^2}\n\\]\nand\n\\[\n\\mathcal{F}=\\frac{\\pi \\sqrt{r}}{1-r}\n\\]\nwhere the latter is called the Finesse. With those abbrevations, we obtain\n\\[\nI=\\frac{I_{\\rm max}}{1+4\\left(\\frac{\\mathcal{F}}{\\pi}\\right)^2\\sin^{2}(\\Delta\\phi/2)}\n\\]\nfor the interference of multiple waves with decreasing amplitude.\nThis intensity distribution has a different shape than the one we obtained for multiple waves with the same amplitude.\nWe clearly observe that with increasing Finesse the intensity maxima, which occur at multiples fo \\(\\pi\\) get much narrower. In addition the regions between the maxima show better contrast and fopr higher Finesse we get complete destructive interference.\n\n\n\n\n\n\nLight beating\n\nBeating of two waves\nLet us consider now interference in the time domain. We introduce two monochromatic waves of frequencies \\(\\nu_1\\) and \\(\\nu_2\\). We will denote their amplitudes by \\(\\sqrt{I_1}\\) and \\(\\sqrt{I_2}\\).\nThe total amplitude is thus\n\\[\nU=U_1+U_2 = \\sqrt{I_1} \\exp(i2\\pi\\nu_1 t) + \\sqrt{I_2} \\exp(i2\\pi\\nu_2 t)\n\\]\nsuch that we obtain an Intensity\n\\[\nI=|U|^2 = I_1 + I_2 + 2\\sqrt{I_1I_2}\\cos(2\\pi(\\nu_1-\\nu_2)t)\n\\]\nThe intensity is thus time dependent and oscillates at a frequency \\(\\nu_1-\\nu_2\\), which is the so-called beating frequency. Similar schemes are used in optical heterodyne detection but also in acoustics when tuning your guitar.\n\n\nMultiple wave beating and pulse generation\nConsider now a whole set of \\(M=2L+1\\) each with an amplitude \\(\\sqrt{I_0}\\). The frequencies of the waves are given by \\(\\nu_q=\\nu_0+q\\Delta\\nu\\) with \\(q=-L,\\dots,L\\) with \\(\\nu_0\\) beeing the center frequency of the spectrum and \\(\\Delta \\nu\\) the frequency spacing. We will assume that \\(\\Delta nu&lt;&lt;\\nu_0\\) such that the total amplitude of the waves is given by\n\\[\nU=\\sum_{q=-L}^L \\sqrt{I_0} \\exp(i2\\pi(\\nu_0+q\\Delta\\nu)t)\n\\]\nThe total intensity can then be calculated in the same way as for the multiple source in space before. Using \\(\\phi=2\\pi \\Delta \\nu t\\) we obtained \\[\nI(t)=I_0 \\frac{\\sin^2(M\\pi t/T)}{\\sin^2(\\pi t/T)}\n\\]\nwith \\(T=1/\\Delta\\nu\\) and a maximum intensity of \\(I_{\\rm max}=M^2 I_0\\).\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Parameters\nDelta_nu = 1e9  # 1 GHz\nM = 1000\nI0 = 1  # Normalized initial intensity\nT = 1/Delta_nu  # 1 ns\npulse_width = T/M  # 1 ps\n\n# Create figure with two subplots\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=get_size(15, 10),\n                             gridspec_kw={'width_ratios': [2, 1]})\n\n# Time array for main plot showing multiple pulses\nt_main = np.linspace(-2*T, 2*T, 20000)\n\n# Time array for inset showing single pulse detail\nt_detail = np.linspace(-5*pulse_width, 5*pulse_width, 10000)\n\n# Calculate intensity function (avoiding division by zero)\ndef intensity(t, M, T, I0):\n    # Small value to prevent division by zero\n    eps = 1e-10\n    # Calculate using the formula\n    num = np.sin(M * np.pi * t / T)**2\n    den = np.sin(np.pi * t / T)**2\n    # Handle points where denominator is near zero\n    near_zero = np.abs(np.sin(np.pi * t / T)) &lt; eps\n\n    result = np.zeros_like(t, dtype=float)\n    # For normal points, use formula\n    mask = ~near_zero\n    result[mask] = I0 * num[mask] / den[mask]\n    # For points where denominator is near zero, use limit value\n    result[near_zero] = M**2 * I0\n\n    return result\n\n# Calculate intensities\nI_main = intensity(t_main, M, T, I0)\nI_detail = intensity(t_detail, M, T, I0)\n\n# Maximum intensity\nmax_intensity = M**2 * I0\n\n# Main plot showing multiple pulses\nax1.plot(t_main*1e9, I_main, 'b-')\nax1.set_xlabel('time [ns]')\nax1.set_ylabel(r' $I/I_{0}$')\nax1.grid(True, alpha=0.3)\n\n# Mark maximum intensity\nax1.axhline(y=max_intensity, color='r', linestyle='--')\n\n# Mark period T\nax1.annotate('', xy=(T*1e9, 0.5e6), xytext=(0, 0.5e6),\n           arrowprops=dict(arrowstyle='&lt;-&gt;', color='g'))\nax1.text(0.5*T*1e9, max_intensity*1.1, f'T = 1/Δν = {T*1e9:.1f} ns',\n        color='g', ha='center')\n\n\nax1.set_ylim(0, max_intensity*1.2)\n\n# Detail plot showing single pulse\nax2.plot(t_detail*1e12, I_detail, 'b-')\nax2.set_xlabel('time [ps]')\nax2.set_ylabel(r'$I/I_{0}$')\n\n\n# Mark pulse width\nax2.annotate('', xy=(-pulse_width/1*1e12, max_intensity*1.05),\n           xytext=(pulse_width/1*1e12, max_intensity*1.05),\n           arrowprops=dict(arrowstyle='&lt;-&gt;', color='m'))\nax2.text(0, max_intensity*1.1, f'T/M = {pulse_width*1e12:.1f} ps',\n        color='m', ha='center')\n\nax2.set_ylim(0, max_intensity*1.2)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 2— Multiple wave beating with M=1000 monochromatic waves separated by Δν=1 GHz. The intensity oscillates with period T=1/Δν=1 ns. Each pulse has a width of approximately T/M=1 ps with maximum intensity I_max=M²I₀.",
    "crumbs": [
      "Home",
      "FOUNDATIONS OF PHOTONICS",
      "Lecture 2",
      "Interference"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Photonics",
    "section": "",
    "text": "Photonics Logo\n\n\nPhotonics is a field of science that is manipulating the flow of light. It contains many facets of research involving light propgation from fundamentals involving light matter interaction to applications involving photonic computing with disordered media or single light quanta to adaptive superresolution microscopy. It is one of the fastest growing fields.\nIn this course we will introduce into the field of optics and photonics. We will start with simple but powerful descriptions of light propagation using ray optics to more advanced physics using electromagnetic waves. We will explore Fourier optics, anisotropic media and non-linear optics to lay the foundation to more complex topics in advanced lecture series.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "course-info/schedule.html",
    "href": "course-info/schedule.html",
    "title": "Course Schedule",
    "section": "",
    "text": "The course will be held in two weekly lectures, starting 09.04.2025. The course will be held in English.\n\n\n\n\n\n\nLecture Times\n\n\n\n\nWednesday 15:15 am – 16:45 pm SR532",
    "crumbs": [
      "Home",
      "Course Info",
      "Schedule"
    ]
  },
  {
    "objectID": "course-info/schedule.html#lectures",
    "href": "course-info/schedule.html#lectures",
    "title": "Course Schedule",
    "section": "",
    "text": "The course will be held in two weekly lectures, starting 09.04.2025. The course will be held in English.\n\n\n\n\n\n\nLecture Times\n\n\n\n\nWednesday 15:15 am – 16:45 pm SR532",
    "crumbs": [
      "Home",
      "Course Info",
      "Schedule"
    ]
  },
  {
    "objectID": "course-info/schedule.html#lab-course",
    "href": "course-info/schedule.html#lab-course",
    "title": "Course Schedule",
    "section": "Lab Course",
    "text": "Lab Course\nPossible dates for the lab course will be published in the second half of the semester. A sign-up form will be made available for registration.",
    "crumbs": [
      "Home",
      "Course Info",
      "Schedule"
    ]
  },
  {
    "objectID": "course-info/exam.html",
    "href": "course-info/exam.html",
    "title": "Exam",
    "section": "",
    "text": "Exam Format\n\n\n\nThis course will end with an oral exam of 30 minutes duration. The exams will be held at after the end of the course during the reading period and the week after.\n\n\n\n\n\n\n\n\nExam Eligibility\n\n\n\nThere are no preconditions for taking the exam.",
    "crumbs": [
      "Home",
      "Course Info",
      "Exams"
    ]
  },
  {
    "objectID": "course-info/intructors.html",
    "href": "course-info/intructors.html",
    "title": "Instructors",
    "section": "",
    "text": "Linnéstr. 5, 04103 Leipzig\nOffice: 322\nPhone: +49 341 97 32571\nEmail: lastname@physik.uni-leipzig.de",
    "crumbs": [
      "Home",
      "Course Info",
      "Instructor"
    ]
  },
  {
    "objectID": "course-info/intructors.html#lectures",
    "href": "course-info/intructors.html#lectures",
    "title": "Instructors",
    "section": "",
    "text": "Linnéstr. 5, 04103 Leipzig\nOffice: 322\nPhone: +49 341 97 32571\nEmail: lastname@physik.uni-leipzig.de",
    "crumbs": [
      "Home",
      "Course Info",
      "Instructor"
    ]
  },
  {
    "objectID": "course-info/intructors.html#lab-course",
    "href": "course-info/intructors.html#lab-course",
    "title": "Instructors",
    "section": "Lab Course",
    "text": "Lab Course\n\nFelix Patzschke\n\nLinnéstr. 5, 04103 Leipzig\nOffice: 318\nPhone: +49 341 97 32572\n\n\n\nLisa Rohde\n\nLinnéstr. 5, 04103 Leipzig\nOffice: 127\nPhone: +49 341 97 32581",
    "crumbs": [
      "Home",
      "Course Info",
      "Instructor"
    ]
  },
  {
    "objectID": "contents.html",
    "href": "contents.html",
    "title": "PART I: FOUNDATIONS OF PHOTONICS",
    "section": "",
    "text": "Course overview and historical perspective\nMultiple descriptions of light:\n\nRay optics: eikonal equation, Snell’s law, reflection\nWave optics: wave equation, superposition, interference\nElectromagnetic theory: overview of Maxwell’s equations\nQuantum nature: preview of photon concept\n\nComparative analysis of different light models and their domains of validity\n\n\n\n\n\nMaxwell’s equations and derivation of wave equation\nPlane waves and polarization states\nPoynting vector and energy transport\nReflection and transmission at interfaces\nFresnel equations and Brewster’s angle\nTotal internal reflection and evanescent waves\nWaveguides: basic principles\n\n\n\n\n\nPhotons and wave-particle duality\nQuantization of electromagnetic field\nPhoton statistics:\n\nPoissonian, sub-Poissonian, and super-Poissonian distributions\nSecond-order correlation functions\nHanbury Brown and Twiss experiment\n\nCoherent states, Fock states, and squeezed states\nSpontaneous and stimulated emission"
  },
  {
    "objectID": "contents.html#lecture-1-fundamental-theories-of-light",
    "href": "contents.html#lecture-1-fundamental-theories-of-light",
    "title": "PART I: FOUNDATIONS OF PHOTONICS",
    "section": "",
    "text": "Course overview and historical perspective\nMultiple descriptions of light:\n\nRay optics: eikonal equation, Snell’s law, reflection\nWave optics: wave equation, superposition, interference\nElectromagnetic theory: overview of Maxwell’s equations\nQuantum nature: preview of photon concept\n\nComparative analysis of different light models and their domains of validity"
  },
  {
    "objectID": "contents.html#lecture-2-electromagnetic-theory-of-light",
    "href": "contents.html#lecture-2-electromagnetic-theory-of-light",
    "title": "PART I: FOUNDATIONS OF PHOTONICS",
    "section": "",
    "text": "Maxwell’s equations and derivation of wave equation\nPlane waves and polarization states\nPoynting vector and energy transport\nReflection and transmission at interfaces\nFresnel equations and Brewster’s angle\nTotal internal reflection and evanescent waves\nWaveguides: basic principles"
  },
  {
    "objectID": "contents.html#lecture-3-quantum-nature-of-light",
    "href": "contents.html#lecture-3-quantum-nature-of-light",
    "title": "PART I: FOUNDATIONS OF PHOTONICS",
    "section": "",
    "text": "Photons and wave-particle duality\nQuantization of electromagnetic field\nPhoton statistics:\n\nPoissonian, sub-Poissonian, and super-Poissonian distributions\nSecond-order correlation functions\nHanbury Brown and Twiss experiment\n\nCoherent states, Fock states, and squeezed states\nSpontaneous and stimulated emission"
  },
  {
    "objectID": "contents.html#lecture-4-introduction-to-fourier-optics",
    "href": "contents.html#lecture-4-introduction-to-fourier-optics",
    "title": "PART I: FOUNDATIONS OF PHOTONICS",
    "section": "Lecture 4: Introduction to Fourier Optics",
    "text": "Lecture 4: Introduction to Fourier Optics\n\nMathematical foundations of 2D Fourier transforms\nSpatial frequency domain interpretation\nLinear systems theory in optics\nAmplitude and phase transfer functions\nConvolution theorem and its optical significance\nSpatial filtering concepts"
  },
  {
    "objectID": "contents.html#lecture-5-diffraction-theory-in-fourier-framework",
    "href": "contents.html#lecture-5-diffraction-theory-in-fourier-framework",
    "title": "PART I: FOUNDATIONS OF PHOTONICS",
    "section": "Lecture 5: Diffraction Theory in Fourier Framework",
    "text": "Lecture 5: Diffraction Theory in Fourier Framework\n\nFraunhofer and Fresnel diffraction\nDiffraction integral as a Fourier relationship\nFar-field diffraction patterns\nDiffraction-limited systems\nAperture functions and their Fourier transforms\nMultiple aperture systems and interference"
  },
  {
    "objectID": "contents.html#lecture-6-optical-imaging-systems-and-modern-microscopy",
    "href": "contents.html#lecture-6-optical-imaging-systems-and-modern-microscopy",
    "title": "PART I: FOUNDATIONS OF PHOTONICS",
    "section": "Lecture 6: Optical Imaging Systems and Modern Microscopy",
    "text": "Lecture 6: Optical Imaging Systems and Modern Microscopy\n\nPoint spread function and optical transfer function\nResolution limits and Abbe’s theory\nFrequency space representation of imaging\nCoherent vs. incoherent imaging\nModern microscopy techniques overview\nSuper-resolution concepts and approaches"
  },
  {
    "objectID": "contents.html#lecture-7-advanced-microscopy-sim-and-computational-imaging",
    "href": "contents.html#lecture-7-advanced-microscopy-sim-and-computational-imaging",
    "title": "PART I: FOUNDATIONS OF PHOTONICS",
    "section": "Lecture 7: Advanced Microscopy: SIM and Computational Imaging",
    "text": "Lecture 7: Advanced Microscopy: SIM and Computational Imaging\n\nStructured Illumination Microscopy (SIM) theory\nFrequency space extension in SIM\nComputational imaging fundamentals\nPhase retrieval and ptychography\nFourier ptychographic microscopy\nMachine learning in computational imaging\nComparison of different super-resolution techniques"
  },
  {
    "objectID": "contents.html#lecture-8-nonlinear-optics-i",
    "href": "contents.html#lecture-8-nonlinear-optics-i",
    "title": "PART I: FOUNDATIONS OF PHOTONICS",
    "section": "Lecture 8: Nonlinear Optics I",
    "text": "Lecture 8: Nonlinear Optics I\n\nOptical nonlinearity origins\nNonlinear susceptibility tensors\nSecond-order nonlinear effects\nSecond harmonic generation\nSum and difference frequency generation\nPhase matching conditions and techniques\nApplications in frequency conversion"
  },
  {
    "objectID": "contents.html#lecture-9-nonlinear-optics-ii",
    "href": "contents.html#lecture-9-nonlinear-optics-ii",
    "title": "PART I: FOUNDATIONS OF PHOTONICS",
    "section": "Lecture 9: Nonlinear Optics II",
    "text": "Lecture 9: Nonlinear Optics II\n\nThird-order nonlinear effects\nSelf-phase modulation and self-focusing\nFour-wave mixing processes\nOptical Kerr effect\nNonlinear absorption phenomena\nApplications in optical switching and computing\nNonlinear microscopy techniques"
  },
  {
    "objectID": "contents.html#lecture-10-nonlinear-optics-iii",
    "href": "contents.html#lecture-10-nonlinear-optics-iii",
    "title": "PART I: FOUNDATIONS OF PHOTONICS",
    "section": "Lecture 10: Nonlinear Optics III",
    "text": "Lecture 10: Nonlinear Optics III\n\nRaman and Brillouin scattering\nMultiphoton processes\nHigh harmonic generation\nNonlinear optics with structured light"
  },
  {
    "objectID": "contents.html#lecture-11-acousto-optics",
    "href": "contents.html#lecture-11-acousto-optics",
    "title": "PART I: FOUNDATIONS OF PHOTONICS",
    "section": "Lecture 11: Acousto-Optics",
    "text": "Lecture 11: Acousto-Optics\n\nSound waves and their interaction with light\nAcousto-optic effect theory\nRaman-Nath and Bragg diffraction regimes\nAcousto-optic devices:\n\nModulators and deflectors\nTunable filters\nFrequency shifters\n\nApplications in imaging and signal processing"
  },
  {
    "objectID": "contents.html#lecture-12-plasmonics",
    "href": "contents.html#lecture-12-plasmonics",
    "title": "PART I: FOUNDATIONS OF PHOTONICS",
    "section": "Lecture 12: Plasmonics",
    "text": "Lecture 12: Plasmonics\n\nIntroduction to plasmons and electron plasma oscillations\nSurface plasmon polaritons: theory and dispersion relations\nExcitation methods (prism, grating)\nLocalized surface plasmons in nanostructures\nField enhancement effects\nPlasmon resonance sensing\nNear-field enhancement applications"
  },
  {
    "objectID": "contents.html#lecture-13-advanced-topics-and-future-directions",
    "href": "contents.html#lecture-13-advanced-topics-and-future-directions",
    "title": "PART I: FOUNDATIONS OF PHOTONICS",
    "section": "Lecture 13: Advanced Topics and Future Directions",
    "text": "Lecture 13: Advanced Topics and Future Directions\n\nIntegrated photonics overview\nPhotonic crystals and metamaterials\nQuantum photonic technologies\nOptical computing advances\nRecent breakthroughs in microscopy\nEmerging trends in nanophotonics\nCourse summary and comprehensive review"
  },
  {
    "objectID": "course-info/labcourse.html",
    "href": "course-info/labcourse.html",
    "title": "Lab Course",
    "section": "",
    "text": "At the end of the course, we will conduct a block lab course where students will have the opportunity to apply the principles of Fourier Optics in a hands-on setting. Students should form groups of 4-5 people, and each group will be allocated two days for experimentation.\nThe lab course is designed to promote free experimentation. Each group will:\n\nOn the first day: Brainstorm and develop ideas for experiments using the provided optical equipment, start with experiments\nOn the second day: Carry out the planned experiments and write up the results in the afternoon\n\nWe will provide a set of optical equipment for each group to explore concepts from Fourier Optics in a practical way. Possible dates for the lab course will be published in the second half of the semester. A sign-up form will be made available for registration.",
    "crumbs": [
      "Home",
      "Course Info",
      "Lab Course"
    ]
  },
  {
    "objectID": "course-info/resources.html",
    "href": "course-info/resources.html",
    "title": "Resources for Introduction to Photonics",
    "section": "",
    "text": "I will refer in the lecture to several resources from which I have listed here some useful books. The most comprehensive one is Fundamentals of Photonics by Saleh and Teich.\n\nFundamentals of Photonics, Saleh/Teich\nOptics, Hecht\nClassical Electrodynamics, Jackson\nIntroduction to Fourier Optics, Goodman\nOptical Coherence and Quantum Optics, Mandel/Wolf\nNonlinear Optics, Bloembergen\nNonlinear Optics, Boyd\nPlasmonics: Fundamentals and Applications, Maier\nPrinciples of Nano-Optics, Hecht/Nowotny\n\nBesides that, the field of photonics is full of interesting research articles that will appear here as we go:",
    "crumbs": [
      "Home",
      "Course Info",
      "Ressources"
    ]
  },
  {
    "objectID": "Keynote/fermat_interference.html",
    "href": "Keynote/fermat_interference.html",
    "title": "Photonics",
    "section": "",
    "text": "Destructive Interference of Non-Minimal Paths\n\n\n\n\n\nWe can demonstrate that all paths except the shortest one interfere destructively using Feynman’s path integral formulation. In this approach, light takes all possible paths between points A and B, with each path contributing an amplitude with phase \\(e^{iS/\\hbar}\\), where \\(S\\) is the action proportional to the optical path length: \\(S = kL\\) where \\(k = 2\\pi/\\lambda\\) is the wave number.\nTo understand why non-minimal paths cancel out, let’s denote the minimal path as \\(x_0(t)\\) and nearby paths as \\(x_0(t) + \\delta x(t)\\), where \\(\\delta x(t)\\) represents small deviations. The action for these perturbed paths expands as: \\[S[x_0 + \\delta x] = S[x_0] + \\frac{\\delta S}{\\delta x}\\bigg|_{x_0} \\delta x + \\frac{1}{2}\\frac{\\delta^2 S}{\\delta x^2}\\bigg|_{x_0} (\\delta x)^2 + ...\\]\nSince \\(x_0\\) is the extremal path (according to Fermat’s principle), we have \\(\\frac{\\delta S}{\\delta x}\\bigg|_{x_0} = 0\\). This means the first-order term vanishes, leaving the quadratic term as the leading contribution to the phase difference:\n\\[\\Delta\\phi = S[x] - S[x_0] \\approx \\frac{1}{2}\\frac{\\delta^2 S}{\\delta x^2}\\bigg|_{x_0} (\\delta x)^2\\]\nThis quadratic dependence is crucial: as we move away from the minimal path, the phase difference increases as the square of the deviation \\(\\delta x\\). When we consider a specific deviation \\(\\delta x_c\\) where \\(\\Delta\\phi = \\pi\\), paths will contribute with exactly opposite phases compared to the minimal path, leading to destructive interference:\n\\[\\frac{1}{2}\\frac{\\delta^2 S}{\\delta x^2}\\bigg|_{x_0} (\\delta x_c)^2 = \\pi\\]\nFor even larger deviations, the phase differences continue to increase, creating alternating bands of constructive and destructive interference. When summed over all possible paths, these rapidly varying phases cancel each other out.\nFor paths far from the minimal one, the destructive interference is even more pronounced. Mathematically, we can demonstrate this by considering a continuous distribution of paths with optical path lengths \\(L\\). The total amplitude contribution from these paths is given by:\n\\[A = \\int e^{ikL(x)} dx\\]\nFor non-minimal paths, we can parametrize the path length as \\(L(x) = L_0 + \\alpha(x-x_0)^2\\) for some constant \\(\\alpha\\), where \\(x_0\\) corresponds to the minimal path. The amplitude becomes:\n\\[A = \\int e^{ik(L_0 + \\alpha(x-x_0)^2)} dx = e^{ikL_0}\\int e^{ik\\alpha(x-x_0)^2} dx\\]\nThis integral evaluates to:\n\\[A = e^{ikL_0}\\sqrt{\\frac{\\pi}{k\\alpha}}e^{i\\pi/4}\\]\nThe key insight is that the amplitude scales as \\(1/\\sqrt{k\\alpha}\\), which means that as the curvature \\(\\alpha\\) of the path length function increases (as happens far from the minimal path), the contribution to the total amplitude diminishes. This mathematically proves why non-minimal path regions contribute negligibly to the overall path integral.\nThis cancellation mechanism explains why light appears to follow only the path of least time in ray optics. The mathematics shows that constructive interference occurs only for paths very close to the minimal path, while all other paths destructively interfere with their neighbors. This phenomenon emerges naturally from wave properties without requiring quantum mechanical constants like ℏ. We can express this classically by setting \\(S = kL\\) and observing how path differences relative to the wavelength create interference patterns.\n\n\nCode\nfrom matplotlib import cm\n\n# Parameters\nnum_paths = 100\nmin_path_index = num_paths // 2\npath_deviation = np.linspace(-2, 2, num_paths)  # Deviation from minimal path\nalpha = 5  # Curvature parameter controlling phase variation rate\n\n# Calculate phase for each path (quadratic dependence on deviation)\nphases = alpha * path_deviation**2\n\n# Set up the figure\nfig, ax = plt.subplots(figsize=get_size(14, 8))\n\n# Plot phase vs path deviation with a simple blue line and points\nax.plot(path_deviation, phases, '-', color='blue', linewidth=2)\n\n# Highlight the minimal path\nax.axvline(x=0, color='r', linestyle='--', linewidth=2, label='Minimal path')\n\n# Highlight paths near minimal path\nnear_minimal = np.abs(path_deviation) &lt; 0.3\n#ax.scatter(path_deviation[near_minimal], phases[near_minimal],\n#          color='green', s=70, label='Near minimal path', zorder=3)\n\n# Set labels and grid\nax.set_xlabel('path deviation')\nax.set_ylabel('phase [rad]')\n\n\n# Add horizontal lines at multiples of π to show constructive/destructive interference\nfor i in range(int(np.max(phases)/np.pi) + 1):\n    if i == 0:\n        ax.axhline(y=i*np.pi, color='k', linestyle='-', alpha=0.2,\n                  label='Constructive interference')\n    elif i % 2 == 0:\n        ax.axhline(y=i*np.pi, color='k', linestyle='-', alpha=0.2)\n    else:\n        ax.axhline(y=i*np.pi, color='k', linestyle='--', alpha=0.2,\n                  label='Destructive interference' if i==1 else None)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 1— Visualization of path phases in Fermat’s principle. The figure shows how the phase varies with path deviation from the minimal path (marked by the vertical red line at zero). The quadratic relationship between phase and path deviation demonstrates why paths near the minimal one constructively interfere (similar phases), while non-minimal paths tend to cancel through destructive interference (rapidly varying phases)."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "lectures/lecture02/phase_delay.html",
    "href": "lectures/lecture02/phase_delay.html",
    "title": "Photonics",
    "section": "",
    "text": "We would like to describe the wavefront deformation caused by samples or optical components, as it would happen for example in an optical microscope. Let a plane wave be incident on a slab of a material of refractive index \\(n\\) and thickness \\(d\\). The plane wave propagates along the z-axis.\n\n\n\n\n\n\nFigure 1: Plane wave propagating through a slab of material with refractive index \\(n\\) and thickness \\(d\\), showing phase delay\n\n\n\nWe can write down the wavefront deformation using the amplitude transmittance:\n\\[\nt(x,y)=\\frac{U(x,y,d)}{U(x,y,0)}\n\\]\nwhich is just the ratio of the amplitude after the object to the amplitude before the object. Inserting the plane wave and the wavenumber \\(k=n k_0\\), where \\(k_0\\) is the wave number in vacuum, we get:\n\\[\nt(x,y)=\\frac{U(x,y,d)}{U(x,y,0)}=\\frac{\\exp(i n k_0 d)}{\\exp(i k_0 \\cdot 0)}=\\exp(i n k_0 d)\n\\]\n\n\n\n\n\n\nFigure 2: Plane wave propagating through an arbitrary slab of material with refractive index \\(n\\) and thickness \\(d_0\\), showing phase delay\n\n\n\nWe can generalize that to an object of arbitrary shape but with a bounding box of thickness \\(d_0\\) and refractive index \\(n\\). The wave then travels a distance \\(d_0-d(x,y)\\) through vacuum and \\(d(x,y)\\) through the object. The complex transmittance is given by:\n\\[\nt(x,y)=\\frac{U(x,y,d_0)}{U(x,y,0)}=\\exp(i n k_0 d(x,y)) \\exp(i k_0 [d_0-d(x,y)])\n\\]\nwhich can be written as\n\\[\nt(x,y)= h_0 \\cdot \\exp(i(n-1) k_0d(x,y))\n\\]\nwith\n\\[\nh_0=\\exp(i k_0 d_0)\n\\]\n\n\n\n\n\n\nFigure 3: Plane wave propagating through a planoconvex lens with refractive index \\(n\\), thickness \\(d_0\\) and a radius \\(R\\).\n\n\n\nWe can apply that for example to a spherical lens of radius \\(R\\) and refractive index \\(n\\) with a planar back side. The lens has a thickness \\(d_0\\)\nThe distance the light has to travel through the lens is then given by\n\\[\nd(x,y)=d_0 -\\lbrace R-\\sqrt{R^2-(x^2+y^2)}\\rbrace\n\\]\nfor \\(x^2+y^2&lt;R^2\\) we can write\n\\[\nR-\\sqrt{R^2-(x^2+y^2)}\\approx \\frac{x^2+y^2}{2R}\n\\]\nsuch that\n\\[\nt(x,y)\\approx h_0 \\cdot \\exp(i(n-1) k_0 d_0) \\cdot \\exp(-i(n-1)k_0 \\frac{x^2+y^2}{2R})\n\\]\nWith \\(h_0'=\\exp(i n k_0 d_0)\\) and the focal distance \\(f=R/(n-1)\\), this becomes:\n\\[\nt(x,y)\\approx h_0' \\exp(-i k_0 \\frac{x^2+y^2}{2f})\n\\]\nThe plane wavefronts are thus bending into paraboloidal wavefronts with a center at \\(f\\).\nThis mathematical framework of amplitude transmittance functions will be crucial when we explore Fourier optics and its applications in microscopy. In particular, these transmittance expressions allow us to predict how wavefronts transform through complex optical systems and how microscope images form. The quadratic phase factors we derived for lenses will play a central role in understanding image formation, resolution limits, and the point spread function in microscopy systems. They also provide the foundation for analyzing more advanced techniques such as phase-contrast microscopy and optical transfer functions."
  },
  {
    "objectID": "lectures/lecture02/phase_delay.html#transmission-through-optical-components",
    "href": "lectures/lecture02/phase_delay.html#transmission-through-optical-components",
    "title": "Photonics",
    "section": "",
    "text": "We would like to describe the wavefront deformation caused by samples or optical components, as it would happen for example in an optical microscope. Let a plane wave be incident on a slab of a material of refractive index \\(n\\) and thickness \\(d\\). The plane wave propagates along the z-axis.\n\n\n\n\n\n\nFigure 1: Plane wave propagating through a slab of material with refractive index \\(n\\) and thickness \\(d\\), showing phase delay\n\n\n\nWe can write down the wavefront deformation using the amplitude transmittance:\n\\[\nt(x,y)=\\frac{U(x,y,d)}{U(x,y,0)}\n\\]\nwhich is just the ratio of the amplitude after the object to the amplitude before the object. Inserting the plane wave and the wavenumber \\(k=n k_0\\), where \\(k_0\\) is the wave number in vacuum, we get:\n\\[\nt(x,y)=\\frac{U(x,y,d)}{U(x,y,0)}=\\frac{\\exp(i n k_0 d)}{\\exp(i k_0 \\cdot 0)}=\\exp(i n k_0 d)\n\\]\n\n\n\n\n\n\nFigure 2: Plane wave propagating through an arbitrary slab of material with refractive index \\(n\\) and thickness \\(d_0\\), showing phase delay\n\n\n\nWe can generalize that to an object of arbitrary shape but with a bounding box of thickness \\(d_0\\) and refractive index \\(n\\). The wave then travels a distance \\(d_0-d(x,y)\\) through vacuum and \\(d(x,y)\\) through the object. The complex transmittance is given by:\n\\[\nt(x,y)=\\frac{U(x,y,d_0)}{U(x,y,0)}=\\exp(i n k_0 d(x,y)) \\exp(i k_0 [d_0-d(x,y)])\n\\]\nwhich can be written as\n\\[\nt(x,y)= h_0 \\cdot \\exp(i(n-1) k_0d(x,y))\n\\]\nwith\n\\[\nh_0=\\exp(i k_0 d_0)\n\\]\n\n\n\n\n\n\nFigure 3: Plane wave propagating through a planoconvex lens with refractive index \\(n\\), thickness \\(d_0\\) and a radius \\(R\\).\n\n\n\nWe can apply that for example to a spherical lens of radius \\(R\\) and refractive index \\(n\\) with a planar back side. The lens has a thickness \\(d_0\\)\nThe distance the light has to travel through the lens is then given by\n\\[\nd(x,y)=d_0 -\\lbrace R-\\sqrt{R^2-(x^2+y^2)}\\rbrace\n\\]\nfor \\(x^2+y^2&lt;R^2\\) we can write\n\\[\nR-\\sqrt{R^2-(x^2+y^2)}\\approx \\frac{x^2+y^2}{2R}\n\\]\nsuch that\n\\[\nt(x,y)\\approx h_0 \\cdot \\exp(i(n-1) k_0 d_0) \\cdot \\exp(-i(n-1)k_0 \\frac{x^2+y^2}{2R})\n\\]\nWith \\(h_0'=\\exp(i n k_0 d_0)\\) and the focal distance \\(f=R/(n-1)\\), this becomes:\n\\[\nt(x,y)\\approx h_0' \\exp(-i k_0 \\frac{x^2+y^2}{2f})\n\\]\nThe plane wavefronts are thus bending into paraboloidal wavefronts with a center at \\(f\\).\nThis mathematical framework of amplitude transmittance functions will be crucial when we explore Fourier optics and its applications in microscopy. In particular, these transmittance expressions allow us to predict how wavefronts transform through complex optical systems and how microscope images form. The quadratic phase factors we derived for lenses will play a central role in understanding image formation, resolution limits, and the point spread function in microscopy systems. They also provide the foundation for analyzing more advanced techniques such as phase-contrast microscopy and optical transfer functions."
  },
  {
    "objectID": "lectures/lecture02/MultiWave Interference.html",
    "href": "lectures/lecture02/MultiWave Interference.html",
    "title": "Multiple Wave Interference",
    "section": "",
    "text": "So far we looked at the interference of two waves, which was a simplification as I mentioned already earlier. Commonly there will be a multitude of partial waves contribute to the oberved intereference. This is what we would like to have a look at now. We will do that in a quite general fashion, as the resulting formulas will appear several times again for different problems.\nNevertheless we will make a difference between\nEspecially the latter is often occuring, if we have multiple reflections and each reflection is only a fraction of the incident amplitude."
  },
  {
    "objectID": "lectures/lecture02/MultiWave Interference.html#light-beating",
    "href": "lectures/lecture02/MultiWave Interference.html#light-beating",
    "title": "Multiple Wave Interference",
    "section": "Light beating",
    "text": "Light beating\n\nBeating of two waves\nLet us consider now interference in the time domain. We introduce two monochromatic waves of frequencies \\(\\nu_1\\) and \\(\\nu_2\\). We will denote their amplitudes by \\(\\sqrt{I_1}\\) and \\(\\sqrt{I_2}\\).\nThe total amplitude is thus\n\\[\nU=U_1+U_2 = \\sqrt{I_1} \\exp(i2\\pi\\nu_1 t) + \\sqrt{I_2} \\exp(i2\\pi\\nu_2 t)\n\\]\nsuch that we obtain an Intensity\n\\[\nI=|U|^2 = I_1 + I_2 + 2\\sqrt{I_1I_2}\\cos(2\\pi(\\nu_1-\\nu_2)t)\n\\]\nThe intensity is thus time dependent and oscillates at a frequency \\(\\nu_1-\\nu_2\\), which is the so-called beating frequency. Similar schemes are used in optical heterodyne detection but also in acoustics when tuning your guitar.\n\n\nMultiple wave beating and pulse generation\nConsider now a whole set of \\(M=2L+1\\) each with an amplitude \\(\\sqrt{I_0}\\). The frequencies of the waves are given by \\(\\nu_q=\\nu_0+q\\Delta\\nu\\) with \\(q=-L,\\dots,L\\) with \\(\\nu_0\\) beeing the center frequency of the spectrum and \\(\\Delta \\nu\\) the frequency spacing. We will assume that \\(\\Delta nu&lt;&lt;\\nu_0\\) such that the total amplitude of the waves is given by\n\\[\nU=\\sum_{q=-L}^L \\sqrt{I_0} \\exp(i2\\pi(\\nu_0+q\\Delta\\nu)t)\n\\]\nThe total intensity can then be calculated in the same way as for the multiple source in space before. Using \\(\\phi=2\\pi \\Delta \\nu t\\) we obtained \\[\nI(t)=I_0 \\frac{\\sin^2(M\\pi t/T)}{\\sin^2(\\pi t/T)}\n\\]\nwith \\(T=1/\\Delta\\nu\\) and a maximum intensity of \\(I_{\\rm max}=M^2 I_0\\).\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Parameters\nDelta_nu = 1e9  # 1 GHz\nM = 1000\nI0 = 1  # Normalized initial intensity\nT = 1/Delta_nu  # 1 ns\npulse_width = T/M  # 1 ps\n\n# Create figure with two subplots\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=get_size(15, 10),\n                             gridspec_kw={'width_ratios': [2, 1]})\n\n# Time array for main plot showing multiple pulses\nt_main = np.linspace(-2*T, 2*T, 20000)\n\n# Time array for inset showing single pulse detail\nt_detail = np.linspace(-5*pulse_width, 5*pulse_width, 10000)\n\n# Calculate intensity function (avoiding division by zero)\ndef intensity(t, M, T, I0):\n    # Small value to prevent division by zero\n    eps = 1e-10\n    # Calculate using the formula\n    num = np.sin(M * np.pi * t / T)**2\n    den = np.sin(np.pi * t / T)**2\n    # Handle points where denominator is near zero\n    near_zero = np.abs(np.sin(np.pi * t / T)) &lt; eps\n\n    result = np.zeros_like(t, dtype=float)\n    # For normal points, use formula\n    mask = ~near_zero\n    result[mask] = I0 * num[mask] / den[mask]\n    # For points where denominator is near zero, use limit value\n    result[near_zero] = M**2 * I0\n\n    return result\n\n# Calculate intensities\nI_main = intensity(t_main, M, T, I0)\nI_detail = intensity(t_detail, M, T, I0)\n\n# Maximum intensity\nmax_intensity = M**2 * I0\n\n# Main plot showing multiple pulses\nax1.plot(t_main*1e9, I_main, 'b-')\nax1.set_xlabel('time [ns]')\nax1.set_ylabel(r' $I/I_{0}$')\nax1.grid(True, alpha=0.3)\n\n# Mark maximum intensity\nax1.axhline(y=max_intensity, color='r', linestyle='--')\n\n# Mark period T\nax1.annotate('', xy=(T*1e9, 0.5e6), xytext=(0, 0.5e6),\n           arrowprops=dict(arrowstyle='&lt;-&gt;', color='g'))\nax1.text(0.5*T*1e9, max_intensity*1.1, f'T = 1/Δν = {T*1e9:.1f} ns',\n        color='g', ha='center')\n\n\nax1.set_ylim(0, max_intensity*1.2)\n\n# Detail plot showing single pulse\nax2.plot(t_detail*1e12, I_detail, 'b-')\nax2.set_xlabel('time [ps]')\nax2.set_ylabel(r'$I/I_{0}$')\n\n\n# Mark pulse width\nax2.annotate('', xy=(-pulse_width/1*1e12, max_intensity*1.05),\n           xytext=(pulse_width/1*1e12, max_intensity*1.05),\n           arrowprops=dict(arrowstyle='&lt;-&gt;', color='m'))\nax2.text(0, max_intensity*1.1, f'T/M = {pulse_width*1e12:.1f} ps',\n        color='m', ha='center')\n\nax2.set_ylim(0, max_intensity*1.2)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 2— Multiple wave beating with M=1000 monochromatic waves separated by Δν=1 GHz. The intensity oscillates with period T=1/Δν=1 ns. Each pulse has a width of approximately T/M=1 ps with maximum intensity I_max=M²I₀."
  },
  {
    "objectID": "lectures/lecture01/introduction.html",
    "href": "lectures/lecture01/introduction.html",
    "title": "Introduction",
    "section": "",
    "text": "RC Time Constants: As circuit dimensions shrink, the RC time constant doesn’t scale favorably, creating a fundamental speed limit for electronic signal propagation.\nJoule Heating: Current flow through resistive elements produces heat proportional to I²R, which becomes increasingly problematic as device density increases according to Moore’s Law.\nSkin Effect: At high frequencies, current flows primarily near conductor surfaces due to electromagnetic field penetration limitations, increasing effective resistance.\nElectromagnetic Interference: Current-carrying wires act as both transmitters and receivers of electromagnetic radiation, creating cross-talk issues that worsen with frequency."
  },
  {
    "objectID": "lectures/lecture01/introduction.html#fundamental-physical-limitations-of-electronics",
    "href": "lectures/lecture01/introduction.html#fundamental-physical-limitations-of-electronics",
    "title": "Introduction",
    "section": "",
    "text": "RC Time Constants: As circuit dimensions shrink, the RC time constant doesn’t scale favorably, creating a fundamental speed limit for electronic signal propagation.\nJoule Heating: Current flow through resistive elements produces heat proportional to I²R, which becomes increasingly problematic as device density increases according to Moore’s Law.\nSkin Effect: At high frequencies, current flows primarily near conductor surfaces due to electromagnetic field penetration limitations, increasing effective resistance.\nElectromagnetic Interference: Current-carrying wires act as both transmitters and receivers of electromagnetic radiation, creating cross-talk issues that worsen with frequency."
  },
  {
    "objectID": "lectures/lecture01/introduction.html#advantages-from-maxwells-equations-perspective",
    "href": "lectures/lecture01/introduction.html#advantages-from-maxwells-equations-perspective",
    "title": "Introduction",
    "section": "Advantages from Maxwell’s Equations Perspective",
    "text": "Advantages from Maxwell’s Equations Perspective\n\nPhoton vs. Electron Energy: Photons at optical frequencies (~10^14 Hz) have energies of ~1-2 eV, while electronic transitions in semiconductors operate at much lower energies, enabling fundamentally higher information bandwidth.\nWave-Particle Nature: Light’s dual nature allows it to be guided, focused, and manipulated without the scattering mechanisms that limit electron transport in solids.\nDispersion Relations: The dispersion relation for photons in waveguides can be engineered more flexibly than electronic band structures in semiconductors."
  },
  {
    "objectID": "lectures/lecture01/introduction.html#quantitative-comparisons",
    "href": "lectures/lecture01/introduction.html#quantitative-comparisons",
    "title": "Introduction",
    "section": "Quantitative Comparisons",
    "text": "Quantitative Comparisons\n\nInformation Capacity: According to Shannon’s theorem, channel capacity increases linearly with bandwidth. Optical frequencies (~100 THz) offer approximately 10,000 times more bandwidth than the highest practical electronic frequencies (~10 GHz).\nPropagation Losses: Modern optical fibers achieve losses of ~0.2 dB/km, while electronic transmission lines typically experience losses of 10-100 dB/km at high frequencies.\nEnergy Per Bit: Theoretical minimum energy to transmit one bit optically is orders of magnitude lower than electronic transmission (~10^-18 J vs ~10^-15 J)."
  },
  {
    "objectID": "lectures/lecture01/introduction.html#quantum-mechanical-considerations",
    "href": "lectures/lecture01/introduction.html#quantum-mechanical-considerations",
    "title": "Introduction",
    "section": "Quantum Mechanical Considerations",
    "text": "Quantum Mechanical Considerations\n\nCoherence Properties: Photons maintain quantum coherence over much longer distances than electrons in solid-state environments, enabling quantum information applications.\nNon-interacting Bosons: Unlike electrons (fermions), photons don’t directly interact with each other, allowing signals to cross without interference."
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html",
    "href": "lectures/lecture01/01-lecture01.html",
    "title": "Photonics",
    "section": "",
    "text": "Light has been described through increasingly sophisticated theoretical frameworks throughout the history of physics. The simplest framework is Ray Optics or Geometrical Optics, which treats light as rays traveling along straight paths and applies geometrical principles to describe interactions with optical elements like lenses and mirrors. Moving beyond this approximation, Wave Optics introduces the wave nature of light, explaining phenomena such as interference and diffraction that ray optics cannot address. Electromagnetic Optics further refines our understanding by treating light as electromagnetic waves governed by Maxwell’s equations, providing a complete classical description of light-matter interactions. For intense light sources, Nonlinear Optics becomes essential, describing how materials respond nonlinearly to strong electromagnetic fields, giving rise to frequency conversion and other novel effects. Finally, at the most fundamental level, Quantum Optics treats light as consisting of photons—quantum mechanical particles exhibiting both wave and particle properties—essential for understanding phenomena like spontaneous emission, entanglement, and the quantum nature of light-matter interactions. This course will progressively build your understanding through these increasingly sophisticated frameworks.\n\n\nRay optics, or geometric optics, provides a powerful framework for understanding light propagation when the wavelength is much smaller than the dimensions of optical elements involved. In this approach, light travels along straight lines called rays in homogeneous media, with well-defined paths that can be mathematically traced. This description serves as the foundation for analyzing many optical systems, from simple mirrors to complex microscopes and telescopes.\n\n\nFermat’s Principle forms one of the foundations of ray optics, stating that light travels along the route that takes the total optical path length between any two points to an extremum (commonly a minimum). This optical path length, expressed mathematically as \\(\\int_C n(s)ds\\), represents the effective distance light traverses through media of varying refractive indices. When this quantity is divided by the vacuum speed of light \\(c_0\\), it yields the total travel time required for light to journey between those points.\nIn its integral form:\n\\[\\delta\\int_C n(s)ds = 0\\]\nwhere \\(n(s)\\) is the refractive index along path \\(C\\) and \\(ds\\) is the differential path length.\nThe same principle can be expressed as a differential equation that describes how light bends in media with varying refractive indices:\n\\[\\frac{d}{ds}\\left(n\\frac{d\\mathbf{r}}{ds}\\right) = \\nabla n\\]\nThis equation shows that rays bend toward regions of higher refractive index. In homogeneous media (\\(\\nabla n = 0\\)), it simplifies to \\(\\frac{d^2\\mathbf{r}}{ds^2} = 0\\), confirming that light follows straight lines.\n\n\n\nReflection: At a planar interface, Fermat’s Principle directly yields the law of reflection:\n\\[\\theta_i = \\theta_r\\]\nwhere \\(\\theta_i\\) is the angle of incidence and \\(\\theta_r\\) is the angle of reflection, both measured from the normal to the surface.\n\n\nCode\ndef calculate_path_length(x, start, end):\n    \"\"\"Calculate the total path length from start to point x to end\"\"\"\n    d1 = np.sqrt((x - start[0])**2 + (start[1])**2)\n    d2 = np.sqrt((end[0] - x)**2 + (end[1])**2)\n    return d1 + d2\n\n# Set up the figure\nfig, ax = plt.subplots(figsize=get_size(15, 10))\n\n# Define start and end points\nstart_point = (-4, 3)\nend_point = (4, 3)\n\n# X positions for different possible paths\nx_positions = np.linspace(-3.5, 3.5, 15)\n\n# Calculate path lengths\npath_lengths = [calculate_path_length(x, start_point, end_point) for x in x_positions]\n\n# Find the minimum path (Fermat's principle)\nmin_index = np.argmin(path_lengths)\nmin_x = x_positions[min_index]\n\n# Plot the horizontal line (interface)\nax.axhline(y=0, color='black', linestyle='-', linewidth=1)\n\n# Plot all possible paths\nfor i, x in enumerate(x_positions):\n    if i == min_index:\n        continue  # Skip the minimum path for now\n\n    # Create path\n    verts = [\n        start_point,\n        (x, 0),\n        end_point\n    ]\n    codes = [\n        Path.MOVETO,\n        Path.LINETO,\n        Path.LINETO\n    ]\n    path = Path(verts, codes)\n    patch = patches.PathPatch(path, facecolor='none', edgecolor='gray',\n                             linestyle='--', lw=0.5,alpha=0.65)\n    ax.add_patch(patch)\n\n# Plot the minimum path (Fermat's Principle)\nverts = [\n    start_point,\n    (min_x, 0),\n    end_point\n]\ncodes = [\n    Path.MOVETO,\n    Path.LINETO,\n    Path.LINETO\n]\npath = Path(verts, codes)\npatch = patches.PathPatch(path, facecolor='none', edgecolor='red',\n                         linestyle='-')\nax.add_patch(patch)\n\n# Add dots for the points\nax.plot(start_point[0], start_point[1], 'bo', label='start point')\nax.plot(end_point[0], end_point[1], 'go',  label='end point')\nax.plot(min_x, 0, 'ro',  label='reflection Point')\n\n# Set labels and title\nax.set_xlabel('x-position')\nax.set_ylabel('y-position')\nax.text(-0.7, -1, \"mirror\")\n\n# Set plot limits and legend\nax.set_xlim(-5, 5)\nax.set_ylim(-4, 4)\nax.set_aspect('equal')\nax.legend()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 1— Fermat’s principle for reflection of light at an interface\n\n\n\n\n\n\n\n\n\n\n\nReflection Law Derivation\n\n\n\n\n\nFor reflection at a planar interface, we consider a ray traveling from point A to point B via reflection at point P on a mirror, as illustrated in Fig. \\(\\ref{fig-fermat-reflection}\\). The total path length is \\(L = |AP| + |PB|\\).\nLet’s establish a coordinate system where the mirror lies along the x-axis at y = 0. If point A is at coordinates \\((-a, h_1)\\) and point B is at \\((b, h_2)\\), with the reflection point P at \\((x, 0)\\), the total path length is:\n\\[L(x) = \\sqrt{(x+a)^2 + h_1^2} + \\sqrt{(b-x)^2 + h_2^2}\\]\nAccording to Fermat’s Principle, the actual path minimizes \\(L\\), so we differentiate with respect to \\(x\\) and set it equal to zero:\n\\[\\frac{dL}{dx} = \\frac{x+a}{\\sqrt{(x+a)^2 + h_1^2}} - \\frac{b-x}{\\sqrt{(b-x)^2 + h_2^2}} = 0\\]\nRearranging this equation:\n\\[\\frac{x+a}{\\sqrt{(x+a)^2 + h_1^2}} = \\frac{b-x}{\\sqrt{(b-x)^2 + h_2^2}}\\]\nNow, let’s interpret this geometrically. The angle of incidence \\(\\theta_i\\) is the angle between the incident ray AP and the normal to the mirror (y-axis). Similarly, the angle of reflection \\(\\theta_r\\) is the angle between the reflected ray PB and the normal.\nFrom trigonometry:\n\n\\(\\sin(\\theta_i) = \\frac{x+a}{\\sqrt{(x+a)^2 + h_1^2}}\\)\n\\(\\sin(\\theta_r) = \\frac{b-x}{\\sqrt{(b-x)^2 + h_2^2}}\\)\n\nTherefore, our minimization condition directly yields: \\[\\sin(\\theta_i) = \\sin(\\theta_r)\\]\nSince both angles are measured in the same quadrant (from the normal to the mirror), this equality implies: \\[\\theta_i = \\theta_r\\]\nThis is the law of reflection: the angle of incidence equals the angle of reflection.\nLaw of Reflection: The angle of incidence equals the angle of reflection. \\[\\theta_i = \\theta_r\\]\n\n\n\nRefraction: Between media with different refractive indices, Fermat’s Principle yields Snell’s law:\n\\[n_1\\sin\\theta_1 = n_2\\sin\\theta_2\\]\nwhere \\(\\theta_1\\) and \\(\\theta_2\\) are the angles of incidence and refraction, respectively.\n\n\nCode\ndef calculate_optical_path(x, start, end, n1, n2):\n    \"\"\"Calculate the total optical path length from start to point x to end\"\"\"\n    d1 = n1 * np.sqrt((x - start[0])**2 + (start[1])**2)  # Optical path in medium 1\n    d2 = n2 * np.sqrt((end[0] - x)**2 + (end[1])**2)      # Optical path in medium 2\n    return d1 + d2\n\n# Set up the figure\nfig, ax = plt.subplots(figsize=get_size(15, 10))\n\n# Define start and end points\nstart_point = (-4, 3)\nend_point = (4, -3)\n\n# Define refractive indices\nn1 = 1.0  # Medium 1 (above interface)\nn2 = 1.5  # Medium 2 (below interface)\n\n# X positions for different possible paths\nx_positions = np.linspace(-3.5, 3.5, 15)\n\n# Calculate optical path lengths\noptical_paths = [calculate_optical_path(x, start_point, end_point, n1, n2) for x in x_positions]\n\n# Find the minimum path (Fermat's principle)\nmin_index = np.argmin(optical_paths)\nmin_x = x_positions[min_index]\n\n# Plot the horizontal line (interface)\nax.axhline(y=0, color='black', linestyle='-', linewidth=1)\n\n# Plot all possible paths\nfor i, x in enumerate(x_positions):\n    if i == min_index:\n        continue  # Skip the minimum path for now\n\n    # Create path\n    verts = [\n        start_point,\n        (x, 0),\n        end_point\n    ]\n    codes = [\n        Path.MOVETO,\n        Path.LINETO,\n        Path.LINETO\n    ]\n    path = Path(verts, codes)\n    patch = patches.PathPatch(path, facecolor='none', edgecolor='gray',\n                             linestyle='--', lw=0.5, alpha=0.65)\n    ax.add_patch(patch)\n\n# Plot the minimum path (Fermat's Principle)\nverts = [\n    start_point,\n    (min_x, 0),\n    end_point\n]\ncodes = [\n    Path.MOVETO,\n    Path.LINETO,\n    Path.LINETO\n]\npath = Path(verts, codes)\npatch = patches.PathPatch(path, facecolor='none', edgecolor='red',\n                         linestyle='-', lw=1)\nax.add_patch(patch)\n\n# Add dots for the points\nax.plot(start_point[0], start_point[1], 'bo', label='start')\nax.plot(end_point[0], end_point[1], 'go', label='end')\nax.plot(min_x, 0, 'ro', label='refraction')\n\n# Calculate and draw angles\n# Incident ray\ndx1 = min_x - start_point[0]\ndy1 = 0 - start_point[1]\nincident_angle = np.arctan2(-dy1, dx1)\ntheta1 = np.pi/2 - incident_angle\n\n# Refracted ray\ndx2 = end_point[0] - min_x\ndy2 = end_point[1] - 0\nrefracted_angle = np.arctan2(dy2, dx2)\ntheta2 = np.pi/2 + refracted_angle\n\n# Draw angle arcs\n\n# Add angle labels\nax.text(min_x + 0.3, 0.3, r'$\\theta_1$', color='blue')\nax.text(min_x - 0.5, -0.3, r'$\\theta_2$', color='green')\n\n# Set labels and title\nax.set_xlabel('x-position')\nax.set_ylabel('y-position')\nax.text(-3, 0.5, f\"n₁ = {n1}\", color='blue')\nax.text(-3, -0.5, f\"n₂ = {n2}\", color='green')\n\n# Set plot limits and legend\nax.set_xlim(-5, 5)\nax.set_ylim(-4, 4)\nax.set_aspect('equal')\nax.legend()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 2— Snell’s Law from Fermat’s Principle\n\n\n\n\n\n\n\n\n\n\n\nRefraction Law Derivation\n\n\n\n\n\nFor refraction between two media with different refractive indices, we apply Fermat’s principle to find the path that minimizes the total optical path length. Consider a ray traveling from point A in medium 1 to point B in medium 2, with refraction occurring at point P on the interface, as illustrated in Fig. \\(\\ref{fig-fermat-refraction}\\).\nThe total optical path length is:\n\\[L = n_1|AP| + n_2|PB|\\]\nTo determine the exact refraction point P that minimizes this path, we establish a coordinate system with the interface along the x-axis at y = 0. If point A is at coordinates \\((x_A, y_A)\\) where \\(y_A &gt; 0\\), and point B is at \\((x_B, y_B)\\) where \\(y_B &lt; 0\\), with the refraction point P at \\((x, 0)\\), the total optical path length is:\n\\[L(x) = n_1\\sqrt{(x-x_A)^2 + y_A^2} + n_2\\sqrt{(x_B-x)^2 + y_B^2}\\]\nAccording to Fermat’s Principle, we minimize \\(L\\) by differentiating with respect to \\(x\\) and setting it equal to zero:\n\\[\\frac{dL}{dx} = n_1\\frac{x-x_A}{\\sqrt{(x-x_A)^2 + y_A^2}} - n_2\\frac{x_B-x}{\\sqrt{(x_B-x)^2 + y_B^2}} = 0\\]\nRearranging this equation:\n\\[\\frac{n_1(x-x_A)}{\\sqrt{(x-x_A)^2 + y_A^2}} = \\frac{n_2(x_B-x)}{\\sqrt{(x_B-x)^2 + y_B^2}}\\]\nFrom geometry, we can identify the sine of the angles of incidence and refraction:\n\n\\(\\sin(\\theta_1) = \\frac{|x-x_A|}{|AP|} = \\frac{|x-x_A|}{\\sqrt{(x-x_A)^2 + y_A^2}}\\)\n\\(\\sin(\\theta_2) = \\frac{|x_B-x|}{|PB|} = \\frac{|x_B-x|}{\\sqrt{(x_B-x)^2 + y_B^2}}\\)\n\nTaking the sign into account based on our coordinate system, our minimization condition becomes:\n\\[n_1\\sin(\\theta_1) = n_2\\sin(\\theta_2)\\]\nThis is Snell’s law, stating that the ratio of the sines of the angles of incidence and refraction equals the ratio of the refractive indices of the two media.\nSnell’s Law: The ratio of the sines of the angles of incidence and refraction equals the reciprocal of the ratio of the refractive indices. \\[n_1\\sin\\theta_1 = n_2\\sin\\theta_2\\]\n\n\n\n\n\nCode\ndef snell(n1, n2, theta1):\n    sin_theta2 = n1 * np.sin(theta1) / n2\n    theta2 = np.arcsin(np.clip(sin_theta2, -1, 1))\n    theta2[sin_theta2 &gt; 1] = np.nan\n    return theta2\n\nfig, ax = plt.subplots(figsize=(4, 4))\n\ntheta1 = np.linspace(0, np.pi/2, 1000)\n\ntheta2_1_to_1_5 = snell(1.0, 1.5, theta1)\ntheta2_1_5_to_1 = snell(1.5, 1.0, theta1)\ntheta2_1_to_1 = snell(1.0, 1.0, theta1)\n\nax.plot(np.degrees(theta1), np.degrees(theta2_1_to_1_5), color='blue')\nax.plot(np.degrees(theta1), np.degrees(theta2_1_5_to_1), color='red')\nax.plot(np.degrees(theta1), np.degrees(theta2_1_to_1), color='green', linestyle='--')\n\nax.set_xlabel(r'$\\theta_1$ [°]')\nax.set_ylabel(r'$\\theta_2$ [°]')\nax.set_xlim(0, 90)\nax.set_ylim(0, 90)\n\nax.plot([0, 90], [0, 90], color='gray', linestyle=':', label='y=x')\n\nax.annotate(r'$\\frac{n_2}{n_1}=1.5$', xy=(60, 35), xytext=(50, 20),\n            arrowprops=dict(arrowstyle='-&gt;'), color='blue')\nax.annotate(r'$\\frac{n_1}{n_2}=1.5$', xy=(30, 50), xytext=(10, 70),\n            arrowprops=dict(arrowstyle='-&gt;'), color='red')\nax.annotate(r'$\\frac{n_2}{n_1}=1$', xy=(45, 45), xytext=(65, 50),\n            arrowprops=dict(arrowstyle='-&gt;'), color='green')\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 3— Snell’s law for different combinations of refractive indices. The plots show the relationship between incident angle (\\(\\theta_1\\)) and refracted angle (\\(\\theta_2\\)) for three scenarios: (a) light passing from air to glass, (b) light passing from glass to air, and (c) a comparison of both cases. Note how the curves differ when light moves into a medium with higher refractive index versus a lower refractive index.\n\n\n\n\n\n\n\nWhen light travels from a medium with a higher refractive index (\\(n_1\\)) to one with a lower refractive index (\\(n_2\\)), a fascinating phenomenon can occur. As the angle of incidence increases, the refracted ray bends away from the normal until, at a critical angle, it travels along the boundary between the two media. Beyond this critical angle, light can no longer pass into the second medium and is instead completely reflected back into the first medium. This phenomenon is known as total internal reflection (TIR).\nFrom Snell’s law, the critical angle \\(\\theta_c\\) occurs when the refracted angle \\(\\theta_2 = 90°\\):\n\\[n_1\\sin\\theta_c = n_2\\sin(90°) = n_2\\]\nTherefore:\n\\[\\theta_c = \\arcsin\\left(\\frac{n_2}{n_1}\\right)\\]\nFor total internal reflection to occur, two conditions must be satisfied:\n\nLight must travel from a higher to a lower refractive index medium (\\(n_1 &gt; n_2\\))\nThe angle of incidence must exceed the critical angle (\\(\\theta_1 &gt; \\theta_c\\))\n\nFrom Fermat’s principle perspective, total internal reflection represents a scenario where no physical path through the second medium can satisfy the minimum optical path length requirement. Instead, the path of least time becomes the reflected path within the original medium. This phenomenon has numerous practical applications, including:\n\nFiber optic communication: Light signals travel long distances through optical fibers via successive total internal reflections with minimal loss\nPrisms and reflectors: Total internal reflection in prisms provides perfect reflection without needing reflective coatings\nGemstones: The brilliance of diamonds results from light being trapped through multiple internal reflections\nOptical instruments: Binoculars, periscopes, and endoscopes use prisms with TIR to redirect light\n\nTotal internal reflection demonstrates how Fermat’s principle enforces an absolute constraint on light’s behavior—when no path through the second medium can minimize the optical path length, light must remain in the first medium, following the path of least time.\nOptical Fibers and Total Internal Reflection\nTotal internal reflection plays a crucial role in modern telecommunications, particularly in optical fibers, which are also part of many experimental setups. These fibers are essentially ultra-thin glass wires, ranging in diameter from a few micrometers to several hundred micrometers, designed to transport light over long distances with minimal loss.\nThe structure of an optical fiber is key to its function:\n\nCore: A central glass core with a refractive index \\(n_1\\)\nCladding: A surrounding layer with a slightly lower refractive index \\(n_2\\)\n\nThis difference in refractive indices is what allows total internal reflection to occur within the fiber.\n\n\n\n\n\n\nFigure 4— Total internal reflection in an optical fiber.\n\n\n\nFor light to propagate effectively through the fiber, it must enter at an angle that ensures total internal reflection at the core-cladding interface. This leads to the concept of the acceptance angle, \\(\\theta_a\\), which is the maximum angle at which light can enter the fiber and still undergo total internal reflection.\nTo characterize this acceptance angle, optical engineers use a parameter called the Numerical Aperture (NA).\n\n\n\n\n\n\nNumerical Aperture\n\n\n\nThe Numerical Aperture of a fiber is defined as the sine of the maximum acceptance angle:\n\\[\\begin{equation}\nNA = \\sin(\\theta_a) = \\sqrt{n_1^2 - n_2^2}\n\\end{equation}\\]\n\n\nThis equation relates the NA directly to the refractive indices of the core and cladding. The derivation of this formula involves applying Snell’s law at the air-fiber interface and at the core-cladding interface, then using the condition for total internal reflection.\nIn practice, typical values for the refractive indices might be \\(n_1 = 1.475\\) for the core and \\(n_2 = 1.46\\) for the cladding. Plugging these into our equation:\n\\[\\begin{equation}\nNA = \\sqrt{1.475^2 - 1.46^2} \\approx 0.2\n\\end{equation}\\]\nThis means that light entering the fiber within a cone of about 11.5° (arcsin(0.2)) from the fiber’s axis will be transmitted through the fiber via total internal reflection.\nThe NA is an important parameter in fiber optic design:\n\nIt determines the light-gathering ability of the fiber.\nIt affects the fiber’s bandwidth and its susceptibility to certain types of signal distortion.\nIt influences how easily the fiber can be coupled to light sources and other fibers.\n\nOptical fibers come in various types, each optimized for different applications. Some fibers are designed to transmit light over long distances with minimal loss, while others are engineered for specific wavelengths or to guide light in unusual ways. The figure below shows a few examples of optical fiber types.\n\n\n\n\n\n\nFigure 5— Rendering of different optical fibers types (from left to right): Hollow core optical fiber, hollow core bragg fiber, photonic crystal fiber, conventional fiber\n\n\n\n\n\n\n\n\nTo derive the differential ray equation from Fermat’s integral principle, we apply the calculus of variations. Starting with the optical path length functional:\n\\[L = \\int_C n(s)ds = \\int_{t_1}^{t_2} n(\\mathbf{r}(t)) \\left|\\frac{d\\mathbf{r}}{dt}\\right| dt\\]\nWhere \\(\\mathbf{r}(t)\\) parametrizes the path. The term \\(\\left|\\frac{d\\mathbf{r}}{dt}\\right|\\) represents the differential element of arc length \\(ds\\) along the path, so \\(ds = \\left|\\frac{d\\mathbf{r}}{dt}\\right| dt\\). This parametrization allows us to convert the path integral over the curve \\(C\\) into a definite integral over the parameter \\(t\\). According to Fermat’s principle, the true path makes this integral stationary (δL = 0).\nConsider a small variation in the path: \\(\\mathbf{r}(t) \\rightarrow \\mathbf{r}(t) + \\epsilon\\mathbf{\\eta}(t)\\) where \\(\\mathbf{\\eta}(t_1) = \\mathbf{\\eta}(t_2) = 0\\) (fixed endpoints). Expanding the variation of the integral to first order in ε:\n\\[\\delta L = \\frac{d}{d\\epsilon}\\bigg|_{\\epsilon=0} \\int_{t_1}^{t_2} n(\\mathbf{r}(t) + \\epsilon\\mathbf{\\eta}(t)) \\left|\\frac{d}{dt}(\\mathbf{r}(t) + \\epsilon\\mathbf{\\eta}(t))\\right| dt\\]\nUsing the chain rule and reparametrizing with arc length \\(s\\) (where \\(\\frac{d\\mathbf{r}}{ds}\\) is a unit vector), the stationarity condition leads to:\n\\[\\int_C \\left[ \\nabla n \\cdot \\mathbf{\\eta} - \\frac{d}{ds}\\left(n\\frac{d\\mathbf{r}}{ds}\\right) \\cdot \\mathbf{\\eta} \\right] ds = 0\\]\nSince this must hold for any variation \\(\\mathbf{\\eta}\\), we obtain the Euler-Lagrange equation:\n\\[\\frac{d}{ds}\\left(n\\frac{d\\mathbf{r}}{ds}\\right) = \\nabla n\\]\nThis shows that rays bend toward regions of higher refractive index, directly analogous to how a mechanical particle’s trajectory is affected by a potential field in classical mechanics.\n\n\n\n\n\n\nSELFOC Gradient Index Lens\n\n\n\n\n\nSELFOC (SELf-FOCusing) gradient-index fibers are interesting optical elements that guide light through a continuous refraction process rather than discrete refractions at interfaces. Let me demonstrate how Fermat’s principle can be used to determine the ray paths in these fibers. A SELFOC fiber has a radially varying refractive index, typically following a parabolic profile:\n\\[n(r) = n_0\\left(1 - \\frac{1}{2}\\alpha^2 r^2\\right)\\]\nwhere: - \\(n_0\\) is the refractive index at the central axis - \\(r\\) is the radial distance from the axis - \\(\\alpha\\) is the gradient constant that determines how quickly the index decreases with radius\n\n\nFor a medium with a spatially varying refractive index, Fermat’s principle states that light follows the path that minimizes the optical path length:\n\\[\\delta \\int_C n(r) ds = 0\\]\nThis yields the differential equation:\n\\[\\frac{d}{ds}\\left(n\\frac{d\\mathbf{r}}{ds}\\right) = \\nabla n\\]\n\n\n\nFor our parabolic index profile, the gradient of the refractive index is:\n\\[\\nabla n = \\frac{\\partial n}{\\partial r}\\hat{\\mathbf{r}} = -n_0\\alpha^2 r \\hat{\\mathbf{r}}\\]\nUsing cylindrical coordinates with z along the fiber axis, and assuming the paraxial approximation (rays make small angles with the z-axis), we can simplify the ray equation to:\n\\[\\frac{d^2r}{dz^2} + \\alpha^2 r = 0\\]\nThis is the equation for a harmonic oscillator, which has the solution:\n\\[r(z) = r_0 \\cos(\\alpha z) + \\frac{\\theta_0}{\\alpha} \\sin(\\alpha z)\\]\nwhere \\(r_0\\) is the initial radial position and \\(\\theta_0\\) is the initial angle of the ray with respect to the fiber axis.\n\n\nCode\n# Parameters\nn0 = 1.5  # Central refractive index\nalpha = 0.3  # Gradient constant (mm^-1)\nlength = 30  # Length of fiber (mm)\nradius = 1.5  # Radius of fiber (mm)\n\n# Create a grid for visualization\nz = np.linspace(0, length, 300)\nr_grid = np.linspace(0, radius, 100)\nZ, R = np.meshgrid(z, r_grid)\n\n# Calculate refractive index at each point\nN = n0 * (1 - 0.5 * (alpha * R)**2)\n\n# Initialize ray paths\nr0_values = [0.6, 1.0, 1.4]  # Initial radial positions\ntheta0_values = [0, 0.2, -0.2]    # Initial angles (all parallel to axis)\n\n# Plot setup\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=get_size(15, 5), gridspec_kw={'width_ratios': [3, 1]})\n\n# Plot the refractive index profile in the first subplot\ncmap = plt.cm.viridis\nextent = [0, length, -radius, radius]\nim = ax1.imshow(np.vstack((N[::-1], N)), extent=extent,\n               aspect='auto', cmap=cmap, origin='lower',alpha=0.2)\nfig.colorbar(im, ax=ax1, label='n(y)')\n\n# Plot ray paths\nfor r0, theta0 in zip(r0_values, theta0_values):\n    # Calculate ray path\n    r = r0 * np.cos(alpha * z) + (theta0/alpha) * np.sin(alpha * z)\n\n    # Plot ray path\n    ax1.plot(z, r, 'r-')\n    ax1.plot(z, -r, 'r-')  # Symmetric ray below axis\n\n# Add labels and title for first subplot\nax1.set_xlabel('z [mm]')\nax1.set_ylabel('y [mm]')\n\n# For the right subplot, plot r-position vs refractive index\n# Create a finer array of radial positions for a smooth curve\nr_positions = np.linspace(0, radius, 100)\n# Calculate refractive index at each radial position\nn_profile = n0 * (1 - 0.5 * (alpha * r_positions)**2)\n\n# Plot the refractive index profile\nax2.plot( n_profile,r_positions, 'k-')\nax2.plot( n_profile,-r_positions, 'k-')\n\n# Set labels for the index profile subplot\nax2.set_xlabel('y [mm]')\nax2.set_ylabel('n(y)')\n\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 6— Ray-path inside a SELFOC gradient index optical fiber.\n\n\n\n\n\n\n\n\n\n\n\n\nThe differential form of Fermat’s principle:\n\\[\\frac{d}{ds}\\left(n\\frac{d\\mathbf{r}}{ds}\\right) = \\nabla n\\]\nreveals a profound analogy with Newton’s Second Law of motion:\n\\[\\mathbf{F} = m\\mathbf{a} = m\\frac{d^2\\mathbf{r}}{dt^2}\\]\nThis comparison, sometimes called “F=ma optics,” illustrates how light rays follow trajectories mathematically similar to those of mechanical particles. To see this connection more clearly, we can expand the ray equation as:\n\\[n\\frac{d^2\\mathbf{r}}{ds^2} + \\frac{d\\mathbf{r}}{ds}\\frac{dn}{ds} = \\nabla n\\]\nUsing the chain rule, \\(\\frac{dn}{ds} = \\nabla n \\cdot \\frac{d\\mathbf{r}}{ds}\\), and denoting \\(\\mathbf{t} = \\frac{d\\mathbf{r}}{ds}\\) as the unit tangent vector along the ray:\n\\[n\\frac{d^2\\mathbf{r}}{ds^2} + (\\nabla n \\cdot \\mathbf{t})\\mathbf{t} = \\nabla n\\]\nRearranging to isolate the ray curvature term:\n\\[n\\frac{d^2\\mathbf{r}}{ds^2} = \\nabla n - (\\nabla n \\cdot \\mathbf{t})\\mathbf{t}\\]\nThe right side represents the component of \\(\\nabla n\\) perpendicular to the ray direction, which we can denote as \\((\\nabla n)_\\perp\\). Therefore:\n\\[\\frac{d^2\\mathbf{r}}{ds^2} = \\frac{1}{n}(\\nabla n)_\\perp\\]\nThis equation reveals that the ray curvature is proportional to the perpendicular component of the refractive index gradient and inversely proportional to the refractive index itself. Crucially, this shows that light rays bend toward regions of higher refractive index, not away from them.\nThis behavior explains many optical phenomena:\n\nLight bending toward the normal when entering a medium with higher refractive index\nLight guiding in optical fibers where light remains confined in the higher-index core\nFormation of mirages where light curves toward the denser air near the ground\nFocusing in gradient-index (GRIN) lenses where the refractive index decreases radially from the center\n\nWhile the mathematical form resembles Newton’s equation for particle motion, the analogy must be carefully interpreted: unlike particles that accelerate toward lower potential energy, light rays curve toward regions of higher refractive index.\n\n\nCode\n# Parameters\nn0 = 1.5  # Base refractive index (center value)\nn_min = 1.0  # Minimum refractive index (at edges)\nx_range = np.linspace(-5, 5, 100)\ny_range = np.linspace(-5, 5, 100)\nX, Y = np.meshgrid(x_range, y_range)\n\n# Calculate radial distance from center\nR = np.sqrt(X**2 + Y**2)\n# Max radius in our plot\nR_max = 5*np.sqrt(2)\n\n# Create a refractive index profile that decreases with radius\n# but never goes below n_min\ngradient_strength = (n0 - n_min)/R_max  # Calculate appropriate gradient strength\nn = n0 - gradient_strength * R  # Linear decrease with radius\n\n# Set up the figure\nfig, ax = plt.subplots(figsize=get_size(12, 10))\n\n# Plot the refractive index as a contour plot\ncontour = ax.contourf(X, Y, n, 20, cmap='viridis', alpha=0.3)\ncbar = fig.colorbar(contour, ax=ax, label='Refractive Index')\n\n# Calculate and plot some ray trajectories\n# We'll simulate the paths by numerical integration\n\ndef ray_path(r0, v0, steps=1000, dt=0.05):\n    \"\"\"Simulate a ray path through the medium\"\"\"\n    r = np.zeros((steps, 2))\n    v = np.zeros((steps, 2))\n    r[0] = r0\n    v[0] = v0 / np.linalg.norm(v0)  # Normalize velocity\n\n    for i in range(1, steps):\n        # Get position\n        x, y = r[i-1]\n        if abs(x) &gt;= 5 or abs(y) &gt;= 5:\n            return r[:i]\n\n        # Approximate gradient of n at this point\n        eps = 0.01\n        nx_plus = n0 - gradient_strength * np.sqrt((x+eps)**2 + y**2)\n        nx_minus = n0 - gradient_strength * np.sqrt((x-eps)**2 + y**2)\n        ny_plus = n0 - gradient_strength * np.sqrt(x**2 + (y+eps)**2)\n        ny_minus = n0 - gradient_strength * np.sqrt(x**2 + (y-eps)**2)\n\n        grad_n_x = (nx_plus - nx_minus) / (2*eps)\n        grad_n_y = (ny_plus - ny_minus) / (2*eps)\n        grad_n = np.array([grad_n_x, grad_n_y])\n\n        # Current n value\n        current_n = n0 - gradient_strength * np.sqrt(x**2 + y**2)\n\n        # Calculate the perpendicular component of gradient\n        t = v[i-1] / np.linalg.norm(v[i-1])  # Tangent vector (normalized velocity)\n        grad_n_parallel = np.dot(grad_n, t) * t  # Component along ray direction\n        grad_n_perp = grad_n - grad_n_parallel  # Perpendicular component\n\n        # Update velocity - rays bend toward higher refractive index\n        a = grad_n_perp / current_n\n        v[i] = v[i-1] + a * dt\n        v[i] = v[i] / np.linalg.norm(v[i])  # Ensure unit speed\n\n        # Update position\n        r[i] = r[i-1] + v[i] * dt\n\n    return r\n\n# Calculate several ray paths\nstart_positions = [\n    [-4, 2.5], [-4, 1.5], [-4, 0.5],\n    [-4, -0.5], [-4, -1.5], [-4, -2.5]\n]\npaths = []\n\nfor start_pos in start_positions:\n    path = ray_path(start_pos, [1, 0], steps=500)\n    paths.append(path)\n    ax.plot(path[:, 0], path[:, 1], 'r-', linewidth=1.5)\n\n# Add start points\nfor pos in start_positions:\n    ax.plot(pos[0], pos[1], 'ro')\n\n# Add axis labels\nax.set_xlabel('x position')\nax.set_ylabel('y position')\nax.set_xlim(-5, 5)\nax.set_ylim(-5, 5)\nax.set_aspect('equal')\nax.grid(True, alpha=0.3)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 7— F=ma optics - Light rays (red) following paths toward regions of higher refractive index\n\n\n\n\n\n\n\n\nLenses are among the most fundamental optical elements in photonics, using curved surfaces (typically spherical) to manipulate light paths. Understanding how lenses work requires analyzing refraction at spherical surfaces and applying this to the thin lens model.\n\n\nWhen light encounters a spherical boundary between two media, we can analyze its path using Snell’s law and geometric considerations as shown below:\n\n\n\n\n\n\nFigure 8— Refraction at a curved surface.\n\n\n\nTo determine how an image forms, we need to find where rays originating from a point at distance \\(a\\) from the surface will converge after refraction. Using Snell’s law for a ray hitting the surface at angle \\(\\alpha+\\theta_1\\):\n\\[n_{1}\\sin(\\alpha+\\theta_1)=n_{2}\\sin(\\alpha-\\theta_2)\\]\nWhere: \\[\\sin(\\alpha)=\\frac{y}{R}, \\quad \\tan(\\theta_1)=\\frac{y}{a}, \\quad \\tan(\\theta_2)=\\frac{y}{b}\\]\nFor practical optical systems, we employ the paraxial approximation, where all angles are assumed small enough that:\n\\[\\sin(\\theta) \\approx \\theta+ O(\\theta^{3}), \\quad \\tan(\\theta) \\approx \\theta + O(\\theta^{3}),\\quad \\cos(\\theta)\\approx 1 + O(\\theta^{2})\\]\nThis simplifies Snell’s law to:\n\\[n_1(\\alpha+\\theta_1)=n_2(\\alpha-\\theta_2)\\]\nAfter appropriate transformations (detailed in the online lecture), we obtain:\n\\[\\theta_2=\\frac{n_2-n_1}{n_2 R}y -\\frac{n_1}{n_2}\\theta_1\\]\nThis linear relationship between input (\\(y\\), \\(\\theta_1\\)) and output (\\(\\theta_2\\)) parameters is a hallmark of paraxial optics.\n\n\n\n\n\n\nParaxial Approximation\n\n\n\n\n\nThe paraxial approximation is a fundamental simplification in optics that assumes all angles are small. This allows us to use linear approximations for trigonometric functions, significantly simplifying calculations while maintaining accuracy for most practical scenarios involving lenses.\nTo visualize the validity of this approximation, let’s examine two plots:\n\nThe first plot compares sin(θ) (blue line) with its linear approximation θ (red dashed line) for angles ranging from 0 to π/2 radians.\nThe second plot shows the absolute error between sin(θ) and θ.\n\nThese plots demonstrate that:\n\nFor small angles (roughly up to 0.5 radians or about 30 degrees), the approximation is very close to the actual sine function.\nThe error increases rapidly for larger angles, indicating the limitations of the paraxial approximation.\n\nIn most optical systems, especially those involving lenses, the angles of incident and refracted rays are typically small enough for this approximation to be valid. However, it’s important to be aware of its limitations when dealing with wide-angle optical systems or scenarios where precision is critical.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n# Define the range of angles (in radians)\ntheta = np.linspace(0, np.pi/2, 1000)\n\n# Calculate sin(theta) and theta (linear approximation)\nsin_theta = np.sin(theta)\nlinear_approx = theta\n\n# Calculate the absolute error\nerror = np.abs(sin_theta - linear_approx)\n\n# Create the plot with two subplots side by side\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(7.5, 4))\n\n# Plot sin(theta) and theta on the first subplot\nax1.plot(theta, sin_theta, label='sin(θ)', color='blue')\nax1.plot(theta, linear_approx, label='θ', color='red', linestyle='--')\nax1.set_xlabel(r'$\\theta$ [rad]')\nax1.set_ylabel(r'$\\sin(x),x$')\nax1.legend()\n\n# Plot the error on the second subplot\nax2.plot(theta, error, label='Absolute Error', color='green')\nax2.set_xlabel(r'$\\theta$ [rad]')\nax2.set_ylabel('|sin(θ) - θ|')\nax2.legend()\n\n# Adjust the layout and display the plot\nplt.tight_layout()\nplt.show()\n\n\n\n\n\nVisualization of the paraxial approximation plotting the \\(\\sin(\\theta)\\) and the linear approximation \\(\\theta\\) (dashed line) for angles ranging from 0 to \\(\\pi/2\\) radians.\n\n\n\n\n\n\n\nTo derive the imaging equation, we analyze how light from a point object forms an image after refraction. Consider two special rays from an off-axis point:\n\n\n\n\n\n\nFigure 9— Image formation at a curved surface.\n\n\n\nFor a ray parallel to the optical axis (\\(\\theta_1=0\\)):\n\\[\\theta_2=\\frac{n_2-n_1}{n_2}\\frac{y}{R}=\\frac{y+\\Delta y}{b}\\]\nFor a ray through the center of curvature (\\(y=0\\)):\n\\[n_2\\frac{\\Delta y}{b}=n_1\\frac{y}{a}\\]\nCombining these equations yields the fundamental imaging equation for a spherical surface:\n\\[\\frac{n_1}{a}+\\frac{n_2}{b}=\\frac{n_2-n_1}{R}\\]\nFrom this, we define the focal length of the spherical surface:\n\\[f=\\frac{n_2}{n_2-n_1}R\\]\n\n\n\n\n\n\nImaging Equation for Spherical Refracting Surface\n\n\n\nThe sum of the inverse object and image distances equals the inverse focal length of the spherical refracting surface:\n\\[\\frac{n_1}{a}+\\frac{n_2}{b}\\approx\\frac{n_2}{f}\\]\nwhere the focal length of the refracting surface is given by:\n\\[f=\\frac{n_2}{n_2-n_1}R\\]\nin the paraxial approximation.\n\n\n\n\n\n\nA lens consists of two spherical surfaces in close proximity. To analyze how a lens forms images, we consider refraction at both surfaces:\n\n\n\n\n\n\nFigure 10— Refraction on two spherical surfaces.\n\n\n\nWhen the lens thickness \\(d\\) is much smaller than the radii of curvature (\\(d \\ll R_1, R_2\\)), we can apply the thin lens approximation. This assumes: 1. The ray height at both surfaces is approximately equal (\\(y \\approx y'\\)) 2. All refraction effectively occurs at a single plane (the principal plane) 3. The change in angle is additive from both surfaces\nThis approximation, combined with the sign convention for radii (positive for convex surfaces facing incoming light, negative for concave), leads to the thin lens formula:\n\n\n\n\n\n\nImaging Equation for Thin Lens\n\n\n\nThe sum of the inverse object and image distances equals the inverse focal length of the thin lens:\n\\[\\frac{1}{a}+\\frac{1}{b}=\\frac{1}{f}\\]\nwhere:\n\\[\\frac{1}{f}=\\frac{n_2-n_1}{n_1}\\left(\\frac{1}{R_1}-\\frac{1}{R_2}\\right)\\]\n\n\nThis can be rearranged to give the lensmaker equation:\n\n\n\n\n\n\nLensmaker Equation\n\n\n\nThe focal length of a thin lens is calculated by: \\[f=\\frac{n_1}{n_2-n_1}\\left(\\frac{R_1 R_2}{R_2-R_1}\\right)\\]\nin the paraxial approximation.\n\n\n\n\nTo construct the image formed by a lens, we typically trace two or three special rays: 1. A ray parallel to the optical axis, which passes through the far focal point after refraction 2. A ray through the center of the lens, which passes undeflected 3. A ray through the near focal point, which emerges parallel to the optical axis\nThe intersection of these rays locates the image position:\n\n\n\n\n\n\nFigure 11— Image construction on a thin lens.\n\n\n\nThe ratio of image height to object height defines the magnification:\n\n\n\n\n\n\nMagnification of a Lens\n\n\n\nThe magnification is given by:\n\\[M=\\frac{h_{\\rm image}}{h_{\\rm object}}=-\\frac{b}{a}=\\frac{f}{f-a}\\]\nwhere the negative sign indicates image inversion for real images.\n\n\nThe image characteristics depend on the object distance relative to the focal length:\n\n\n\n\n\n\n\n\n\nObject Position\nImage Characteristics\nMagnification (M)\nImage Type\n\n\n\n\n\\(a &lt; f\\)\nUpright and magnified\n\\(M &gt; 0\\)\nVirtual\n\n\n\\(f &lt; a &lt; 2f\\)\nInverted and magnified\n\\(M &lt; -1\\)\nReal\n\n\n\\(a = 2f\\)\nInverted, same size\n\\(M = -1\\)\nReal\n\n\n\\(a &gt; 2f\\)\nInverted and reduced\n\\(-1 &lt; M &lt; 0\\)\nReal\n\n\n\\(a = f\\)\nImage at infinity\n\\(M = \\infty\\)\n-\n\n\n\nThe diagram below illustrates these various imaging scenarios for a biconvex lens:\n\n\n\n\n\n\n\n\n\n\n\nFig.: Image construction on a biconvex lens with a parallel and a central ray for different object distances.\n\n\n\n\n\n\n\n\n\nMatrix Optics\n\n\n\n\n\nThe above derived equations for a single spherical surface yield a linear relation between the input variables \\(y_1\\) and \\(\\theta_1\\) and the output variables \\(y_2\\) and \\(\\theta_2\\). The linear relation yields a great opportunity to express optical elements in terms of linear transformations (matrices). This is the basis of matrix optics. The matrix representation of a lens is given by\n\\[\\begin{pmatrix} y_2 \\\\ \\theta_2 \\end{pmatrix} = \\begin{pmatrix} 1 & 0 \\\\ -\\frac{1}{f} & 1 \\end{pmatrix} \\begin{pmatrix} y_1 \\\\ \\theta_1 \\end{pmatrix}\\]\nwhere the matrix is called the ABCD matrix of the lens. Due to the linearization of Snells law w can write down more generally\n\\[\\begin{pmatrix} y_2 \\\\\n\\theta_2 \\end{pmatrix} = \\begin{pmatrix} A & B \\\\ C & D \\end{pmatrix} \\begin{pmatrix} y_1 \\\\ \\theta_1 \\end{pmatrix}\\]\nand one can obtain a Matrix for all types of optical elements such as free space of dustance \\(d\\).\n\\[\\begin{bmatrix}\nA & B\\\\\nC & D\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1 & d\\\\\n0 & 1\n\\end{bmatrix}\n\\]\nHere are some useful matrices for optical elements:\n\\[\n\\mathbf{M}=\\left[\\begin{array}{ll}\n1 & d \\\\\n0 & 1\n\\end{array}\\right] \\tag{Free space}\n\\]\n\\[\n\\mathbf{M}=\\left[\\begin{array}{cc}\n1 & 0 \\\\\n0 & \\frac{n_1}{n_2}\n\\end{array}\\right] \\tag{Planar interface}\n\\]\n\\[\n\\mathbf{M}=\\left[\\begin{array}{cc}\n1 & 0 \\\\\n-\\frac{\\left(n_2-n_1\\right)}{n_2 R} & \\frac{n_1}{n_2}\n\\end{array}\\right] \\tag{Spherical Boundary}\n\\]\n\\[\n\\mathbf{M}=\\left[\\begin{array}{cc}\n1 & 0 \\\\\n-\\frac{1}{f} & 1\n\\end{array}\\right] \\tag{Tin Lens}\n\\]\nIf we have now a system of optical elements, we can multiply the matrices of the individual elements to obtain the matrix of the whole system.\n\\[\n\\rightarrow \\mathrm{M}_1 \\rightarrow \\mathrm{M}_2 \\rightarrow \\mathrm{M}_N \\rightarrow \\mathrm{M}=\\mathbf{M}_N \\ldots \\mathrm{M}_2 \\mathbf{M}_1 \\text {. }\n\\]\nThis is a very powerful tool to analyze optical systems.",
    "crumbs": [
      "Home",
      "FOUNDATIONS OF PHOTONICS",
      "Lecture 1",
      "Ray Optics"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html#theories-for-light",
    "href": "lectures/lecture01/01-lecture01.html#theories-for-light",
    "title": "Photonics",
    "section": "",
    "text": "Light has been described through increasingly sophisticated theoretical frameworks throughout the history of physics. The simplest framework is Ray Optics or Geometrical Optics, which treats light as rays traveling along straight paths and applies geometrical principles to describe interactions with optical elements like lenses and mirrors. Moving beyond this approximation, Wave Optics introduces the wave nature of light, explaining phenomena such as interference and diffraction that ray optics cannot address. Electromagnetic Optics further refines our understanding by treating light as electromagnetic waves governed by Maxwell’s equations, providing a complete classical description of light-matter interactions. For intense light sources, Nonlinear Optics becomes essential, describing how materials respond nonlinearly to strong electromagnetic fields, giving rise to frequency conversion and other novel effects. Finally, at the most fundamental level, Quantum Optics treats light as consisting of photons—quantum mechanical particles exhibiting both wave and particle properties—essential for understanding phenomena like spontaneous emission, entanglement, and the quantum nature of light-matter interactions. This course will progressively build your understanding through these increasingly sophisticated frameworks.\n\n\nRay optics, or geometric optics, provides a powerful framework for understanding light propagation when the wavelength is much smaller than the dimensions of optical elements involved. In this approach, light travels along straight lines called rays in homogeneous media, with well-defined paths that can be mathematically traced. This description serves as the foundation for analyzing many optical systems, from simple mirrors to complex microscopes and telescopes.\n\n\nFermat’s Principle forms one of the foundations of ray optics, stating that light travels along the route that takes the total optical path length between any two points to an extremum (commonly a minimum). This optical path length, expressed mathematically as \\(\\int_C n(s)ds\\), represents the effective distance light traverses through media of varying refractive indices. When this quantity is divided by the vacuum speed of light \\(c_0\\), it yields the total travel time required for light to journey between those points.\nIn its integral form:\n\\[\\delta\\int_C n(s)ds = 0\\]\nwhere \\(n(s)\\) is the refractive index along path \\(C\\) and \\(ds\\) is the differential path length.\nThe same principle can be expressed as a differential equation that describes how light bends in media with varying refractive indices:\n\\[\\frac{d}{ds}\\left(n\\frac{d\\mathbf{r}}{ds}\\right) = \\nabla n\\]\nThis equation shows that rays bend toward regions of higher refractive index. In homogeneous media (\\(\\nabla n = 0\\)), it simplifies to \\(\\frac{d^2\\mathbf{r}}{ds^2} = 0\\), confirming that light follows straight lines.\n\n\n\nReflection: At a planar interface, Fermat’s Principle directly yields the law of reflection:\n\\[\\theta_i = \\theta_r\\]\nwhere \\(\\theta_i\\) is the angle of incidence and \\(\\theta_r\\) is the angle of reflection, both measured from the normal to the surface.\n\n\nCode\ndef calculate_path_length(x, start, end):\n    \"\"\"Calculate the total path length from start to point x to end\"\"\"\n    d1 = np.sqrt((x - start[0])**2 + (start[1])**2)\n    d2 = np.sqrt((end[0] - x)**2 + (end[1])**2)\n    return d1 + d2\n\n# Set up the figure\nfig, ax = plt.subplots(figsize=get_size(15, 10))\n\n# Define start and end points\nstart_point = (-4, 3)\nend_point = (4, 3)\n\n# X positions for different possible paths\nx_positions = np.linspace(-3.5, 3.5, 15)\n\n# Calculate path lengths\npath_lengths = [calculate_path_length(x, start_point, end_point) for x in x_positions]\n\n# Find the minimum path (Fermat's principle)\nmin_index = np.argmin(path_lengths)\nmin_x = x_positions[min_index]\n\n# Plot the horizontal line (interface)\nax.axhline(y=0, color='black', linestyle='-', linewidth=1)\n\n# Plot all possible paths\nfor i, x in enumerate(x_positions):\n    if i == min_index:\n        continue  # Skip the minimum path for now\n\n    # Create path\n    verts = [\n        start_point,\n        (x, 0),\n        end_point\n    ]\n    codes = [\n        Path.MOVETO,\n        Path.LINETO,\n        Path.LINETO\n    ]\n    path = Path(verts, codes)\n    patch = patches.PathPatch(path, facecolor='none', edgecolor='gray',\n                             linestyle='--', lw=0.5,alpha=0.65)\n    ax.add_patch(patch)\n\n# Plot the minimum path (Fermat's Principle)\nverts = [\n    start_point,\n    (min_x, 0),\n    end_point\n]\ncodes = [\n    Path.MOVETO,\n    Path.LINETO,\n    Path.LINETO\n]\npath = Path(verts, codes)\npatch = patches.PathPatch(path, facecolor='none', edgecolor='red',\n                         linestyle='-')\nax.add_patch(patch)\n\n# Add dots for the points\nax.plot(start_point[0], start_point[1], 'bo', label='start point')\nax.plot(end_point[0], end_point[1], 'go',  label='end point')\nax.plot(min_x, 0, 'ro',  label='reflection Point')\n\n# Set labels and title\nax.set_xlabel('x-position')\nax.set_ylabel('y-position')\nax.text(-0.7, -1, \"mirror\")\n\n# Set plot limits and legend\nax.set_xlim(-5, 5)\nax.set_ylim(-4, 4)\nax.set_aspect('equal')\nax.legend()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 1— Fermat’s principle for reflection of light at an interface\n\n\n\n\n\n\n\n\n\n\n\nReflection Law Derivation\n\n\n\n\n\nFor reflection at a planar interface, we consider a ray traveling from point A to point B via reflection at point P on a mirror, as illustrated in Fig. \\(\\ref{fig-fermat-reflection}\\). The total path length is \\(L = |AP| + |PB|\\).\nLet’s establish a coordinate system where the mirror lies along the x-axis at y = 0. If point A is at coordinates \\((-a, h_1)\\) and point B is at \\((b, h_2)\\), with the reflection point P at \\((x, 0)\\), the total path length is:\n\\[L(x) = \\sqrt{(x+a)^2 + h_1^2} + \\sqrt{(b-x)^2 + h_2^2}\\]\nAccording to Fermat’s Principle, the actual path minimizes \\(L\\), so we differentiate with respect to \\(x\\) and set it equal to zero:\n\\[\\frac{dL}{dx} = \\frac{x+a}{\\sqrt{(x+a)^2 + h_1^2}} - \\frac{b-x}{\\sqrt{(b-x)^2 + h_2^2}} = 0\\]\nRearranging this equation:\n\\[\\frac{x+a}{\\sqrt{(x+a)^2 + h_1^2}} = \\frac{b-x}{\\sqrt{(b-x)^2 + h_2^2}}\\]\nNow, let’s interpret this geometrically. The angle of incidence \\(\\theta_i\\) is the angle between the incident ray AP and the normal to the mirror (y-axis). Similarly, the angle of reflection \\(\\theta_r\\) is the angle between the reflected ray PB and the normal.\nFrom trigonometry:\n\n\\(\\sin(\\theta_i) = \\frac{x+a}{\\sqrt{(x+a)^2 + h_1^2}}\\)\n\\(\\sin(\\theta_r) = \\frac{b-x}{\\sqrt{(b-x)^2 + h_2^2}}\\)\n\nTherefore, our minimization condition directly yields: \\[\\sin(\\theta_i) = \\sin(\\theta_r)\\]\nSince both angles are measured in the same quadrant (from the normal to the mirror), this equality implies: \\[\\theta_i = \\theta_r\\]\nThis is the law of reflection: the angle of incidence equals the angle of reflection.\nLaw of Reflection: The angle of incidence equals the angle of reflection. \\[\\theta_i = \\theta_r\\]\n\n\n\nRefraction: Between media with different refractive indices, Fermat’s Principle yields Snell’s law:\n\\[n_1\\sin\\theta_1 = n_2\\sin\\theta_2\\]\nwhere \\(\\theta_1\\) and \\(\\theta_2\\) are the angles of incidence and refraction, respectively.\n\n\nCode\ndef calculate_optical_path(x, start, end, n1, n2):\n    \"\"\"Calculate the total optical path length from start to point x to end\"\"\"\n    d1 = n1 * np.sqrt((x - start[0])**2 + (start[1])**2)  # Optical path in medium 1\n    d2 = n2 * np.sqrt((end[0] - x)**2 + (end[1])**2)      # Optical path in medium 2\n    return d1 + d2\n\n# Set up the figure\nfig, ax = plt.subplots(figsize=get_size(15, 10))\n\n# Define start and end points\nstart_point = (-4, 3)\nend_point = (4, -3)\n\n# Define refractive indices\nn1 = 1.0  # Medium 1 (above interface)\nn2 = 1.5  # Medium 2 (below interface)\n\n# X positions for different possible paths\nx_positions = np.linspace(-3.5, 3.5, 15)\n\n# Calculate optical path lengths\noptical_paths = [calculate_optical_path(x, start_point, end_point, n1, n2) for x in x_positions]\n\n# Find the minimum path (Fermat's principle)\nmin_index = np.argmin(optical_paths)\nmin_x = x_positions[min_index]\n\n# Plot the horizontal line (interface)\nax.axhline(y=0, color='black', linestyle='-', linewidth=1)\n\n# Plot all possible paths\nfor i, x in enumerate(x_positions):\n    if i == min_index:\n        continue  # Skip the minimum path for now\n\n    # Create path\n    verts = [\n        start_point,\n        (x, 0),\n        end_point\n    ]\n    codes = [\n        Path.MOVETO,\n        Path.LINETO,\n        Path.LINETO\n    ]\n    path = Path(verts, codes)\n    patch = patches.PathPatch(path, facecolor='none', edgecolor='gray',\n                             linestyle='--', lw=0.5, alpha=0.65)\n    ax.add_patch(patch)\n\n# Plot the minimum path (Fermat's Principle)\nverts = [\n    start_point,\n    (min_x, 0),\n    end_point\n]\ncodes = [\n    Path.MOVETO,\n    Path.LINETO,\n    Path.LINETO\n]\npath = Path(verts, codes)\npatch = patches.PathPatch(path, facecolor='none', edgecolor='red',\n                         linestyle='-', lw=1)\nax.add_patch(patch)\n\n# Add dots for the points\nax.plot(start_point[0], start_point[1], 'bo', label='start')\nax.plot(end_point[0], end_point[1], 'go', label='end')\nax.plot(min_x, 0, 'ro', label='refraction')\n\n# Calculate and draw angles\n# Incident ray\ndx1 = min_x - start_point[0]\ndy1 = 0 - start_point[1]\nincident_angle = np.arctan2(-dy1, dx1)\ntheta1 = np.pi/2 - incident_angle\n\n# Refracted ray\ndx2 = end_point[0] - min_x\ndy2 = end_point[1] - 0\nrefracted_angle = np.arctan2(dy2, dx2)\ntheta2 = np.pi/2 + refracted_angle\n\n# Draw angle arcs\n\n# Add angle labels\nax.text(min_x + 0.3, 0.3, r'$\\theta_1$', color='blue')\nax.text(min_x - 0.5, -0.3, r'$\\theta_2$', color='green')\n\n# Set labels and title\nax.set_xlabel('x-position')\nax.set_ylabel('y-position')\nax.text(-3, 0.5, f\"n₁ = {n1}\", color='blue')\nax.text(-3, -0.5, f\"n₂ = {n2}\", color='green')\n\n# Set plot limits and legend\nax.set_xlim(-5, 5)\nax.set_ylim(-4, 4)\nax.set_aspect('equal')\nax.legend()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 2— Snell’s Law from Fermat’s Principle\n\n\n\n\n\n\n\n\n\n\n\nRefraction Law Derivation\n\n\n\n\n\nFor refraction between two media with different refractive indices, we apply Fermat’s principle to find the path that minimizes the total optical path length. Consider a ray traveling from point A in medium 1 to point B in medium 2, with refraction occurring at point P on the interface, as illustrated in Fig. \\(\\ref{fig-fermat-refraction}\\).\nThe total optical path length is:\n\\[L = n_1|AP| + n_2|PB|\\]\nTo determine the exact refraction point P that minimizes this path, we establish a coordinate system with the interface along the x-axis at y = 0. If point A is at coordinates \\((x_A, y_A)\\) where \\(y_A &gt; 0\\), and point B is at \\((x_B, y_B)\\) where \\(y_B &lt; 0\\), with the refraction point P at \\((x, 0)\\), the total optical path length is:\n\\[L(x) = n_1\\sqrt{(x-x_A)^2 + y_A^2} + n_2\\sqrt{(x_B-x)^2 + y_B^2}\\]\nAccording to Fermat’s Principle, we minimize \\(L\\) by differentiating with respect to \\(x\\) and setting it equal to zero:\n\\[\\frac{dL}{dx} = n_1\\frac{x-x_A}{\\sqrt{(x-x_A)^2 + y_A^2}} - n_2\\frac{x_B-x}{\\sqrt{(x_B-x)^2 + y_B^2}} = 0\\]\nRearranging this equation:\n\\[\\frac{n_1(x-x_A)}{\\sqrt{(x-x_A)^2 + y_A^2}} = \\frac{n_2(x_B-x)}{\\sqrt{(x_B-x)^2 + y_B^2}}\\]\nFrom geometry, we can identify the sine of the angles of incidence and refraction:\n\n\\(\\sin(\\theta_1) = \\frac{|x-x_A|}{|AP|} = \\frac{|x-x_A|}{\\sqrt{(x-x_A)^2 + y_A^2}}\\)\n\\(\\sin(\\theta_2) = \\frac{|x_B-x|}{|PB|} = \\frac{|x_B-x|}{\\sqrt{(x_B-x)^2 + y_B^2}}\\)\n\nTaking the sign into account based on our coordinate system, our minimization condition becomes:\n\\[n_1\\sin(\\theta_1) = n_2\\sin(\\theta_2)\\]\nThis is Snell’s law, stating that the ratio of the sines of the angles of incidence and refraction equals the ratio of the refractive indices of the two media.\nSnell’s Law: The ratio of the sines of the angles of incidence and refraction equals the reciprocal of the ratio of the refractive indices. \\[n_1\\sin\\theta_1 = n_2\\sin\\theta_2\\]\n\n\n\n\n\nCode\ndef snell(n1, n2, theta1):\n    sin_theta2 = n1 * np.sin(theta1) / n2\n    theta2 = np.arcsin(np.clip(sin_theta2, -1, 1))\n    theta2[sin_theta2 &gt; 1] = np.nan\n    return theta2\n\nfig, ax = plt.subplots(figsize=(4, 4))\n\ntheta1 = np.linspace(0, np.pi/2, 1000)\n\ntheta2_1_to_1_5 = snell(1.0, 1.5, theta1)\ntheta2_1_5_to_1 = snell(1.5, 1.0, theta1)\ntheta2_1_to_1 = snell(1.0, 1.0, theta1)\n\nax.plot(np.degrees(theta1), np.degrees(theta2_1_to_1_5), color='blue')\nax.plot(np.degrees(theta1), np.degrees(theta2_1_5_to_1), color='red')\nax.plot(np.degrees(theta1), np.degrees(theta2_1_to_1), color='green', linestyle='--')\n\nax.set_xlabel(r'$\\theta_1$ [°]')\nax.set_ylabel(r'$\\theta_2$ [°]')\nax.set_xlim(0, 90)\nax.set_ylim(0, 90)\n\nax.plot([0, 90], [0, 90], color='gray', linestyle=':', label='y=x')\n\nax.annotate(r'$\\frac{n_2}{n_1}=1.5$', xy=(60, 35), xytext=(50, 20),\n            arrowprops=dict(arrowstyle='-&gt;'), color='blue')\nax.annotate(r'$\\frac{n_1}{n_2}=1.5$', xy=(30, 50), xytext=(10, 70),\n            arrowprops=dict(arrowstyle='-&gt;'), color='red')\nax.annotate(r'$\\frac{n_2}{n_1}=1$', xy=(45, 45), xytext=(65, 50),\n            arrowprops=dict(arrowstyle='-&gt;'), color='green')\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 3— Snell’s law for different combinations of refractive indices. The plots show the relationship between incident angle (\\(\\theta_1\\)) and refracted angle (\\(\\theta_2\\)) for three scenarios: (a) light passing from air to glass, (b) light passing from glass to air, and (c) a comparison of both cases. Note how the curves differ when light moves into a medium with higher refractive index versus a lower refractive index.\n\n\n\n\n\n\n\nWhen light travels from a medium with a higher refractive index (\\(n_1\\)) to one with a lower refractive index (\\(n_2\\)), a fascinating phenomenon can occur. As the angle of incidence increases, the refracted ray bends away from the normal until, at a critical angle, it travels along the boundary between the two media. Beyond this critical angle, light can no longer pass into the second medium and is instead completely reflected back into the first medium. This phenomenon is known as total internal reflection (TIR).\nFrom Snell’s law, the critical angle \\(\\theta_c\\) occurs when the refracted angle \\(\\theta_2 = 90°\\):\n\\[n_1\\sin\\theta_c = n_2\\sin(90°) = n_2\\]\nTherefore:\n\\[\\theta_c = \\arcsin\\left(\\frac{n_2}{n_1}\\right)\\]\nFor total internal reflection to occur, two conditions must be satisfied:\n\nLight must travel from a higher to a lower refractive index medium (\\(n_1 &gt; n_2\\))\nThe angle of incidence must exceed the critical angle (\\(\\theta_1 &gt; \\theta_c\\))\n\nFrom Fermat’s principle perspective, total internal reflection represents a scenario where no physical path through the second medium can satisfy the minimum optical path length requirement. Instead, the path of least time becomes the reflected path within the original medium. This phenomenon has numerous practical applications, including:\n\nFiber optic communication: Light signals travel long distances through optical fibers via successive total internal reflections with minimal loss\nPrisms and reflectors: Total internal reflection in prisms provides perfect reflection without needing reflective coatings\nGemstones: The brilliance of diamonds results from light being trapped through multiple internal reflections\nOptical instruments: Binoculars, periscopes, and endoscopes use prisms with TIR to redirect light\n\nTotal internal reflection demonstrates how Fermat’s principle enforces an absolute constraint on light’s behavior—when no path through the second medium can minimize the optical path length, light must remain in the first medium, following the path of least time.\nOptical Fibers and Total Internal Reflection\nTotal internal reflection plays a crucial role in modern telecommunications, particularly in optical fibers, which are also part of many experimental setups. These fibers are essentially ultra-thin glass wires, ranging in diameter from a few micrometers to several hundred micrometers, designed to transport light over long distances with minimal loss.\nThe structure of an optical fiber is key to its function:\n\nCore: A central glass core with a refractive index \\(n_1\\)\nCladding: A surrounding layer with a slightly lower refractive index \\(n_2\\)\n\nThis difference in refractive indices is what allows total internal reflection to occur within the fiber.\n\n\n\n\n\n\nFigure 4— Total internal reflection in an optical fiber.\n\n\n\nFor light to propagate effectively through the fiber, it must enter at an angle that ensures total internal reflection at the core-cladding interface. This leads to the concept of the acceptance angle, \\(\\theta_a\\), which is the maximum angle at which light can enter the fiber and still undergo total internal reflection.\nTo characterize this acceptance angle, optical engineers use a parameter called the Numerical Aperture (NA).\n\n\n\n\n\n\nNumerical Aperture\n\n\n\nThe Numerical Aperture of a fiber is defined as the sine of the maximum acceptance angle:\n\\[\\begin{equation}\nNA = \\sin(\\theta_a) = \\sqrt{n_1^2 - n_2^2}\n\\end{equation}\\]\n\n\nThis equation relates the NA directly to the refractive indices of the core and cladding. The derivation of this formula involves applying Snell’s law at the air-fiber interface and at the core-cladding interface, then using the condition for total internal reflection.\nIn practice, typical values for the refractive indices might be \\(n_1 = 1.475\\) for the core and \\(n_2 = 1.46\\) for the cladding. Plugging these into our equation:\n\\[\\begin{equation}\nNA = \\sqrt{1.475^2 - 1.46^2} \\approx 0.2\n\\end{equation}\\]\nThis means that light entering the fiber within a cone of about 11.5° (arcsin(0.2)) from the fiber’s axis will be transmitted through the fiber via total internal reflection.\nThe NA is an important parameter in fiber optic design:\n\nIt determines the light-gathering ability of the fiber.\nIt affects the fiber’s bandwidth and its susceptibility to certain types of signal distortion.\nIt influences how easily the fiber can be coupled to light sources and other fibers.\n\nOptical fibers come in various types, each optimized for different applications. Some fibers are designed to transmit light over long distances with minimal loss, while others are engineered for specific wavelengths or to guide light in unusual ways. The figure below shows a few examples of optical fiber types.\n\n\n\n\n\n\nFigure 5— Rendering of different optical fibers types (from left to right): Hollow core optical fiber, hollow core bragg fiber, photonic crystal fiber, conventional fiber\n\n\n\n\n\n\n\n\nTo derive the differential ray equation from Fermat’s integral principle, we apply the calculus of variations. Starting with the optical path length functional:\n\\[L = \\int_C n(s)ds = \\int_{t_1}^{t_2} n(\\mathbf{r}(t)) \\left|\\frac{d\\mathbf{r}}{dt}\\right| dt\\]\nWhere \\(\\mathbf{r}(t)\\) parametrizes the path. The term \\(\\left|\\frac{d\\mathbf{r}}{dt}\\right|\\) represents the differential element of arc length \\(ds\\) along the path, so \\(ds = \\left|\\frac{d\\mathbf{r}}{dt}\\right| dt\\). This parametrization allows us to convert the path integral over the curve \\(C\\) into a definite integral over the parameter \\(t\\). According to Fermat’s principle, the true path makes this integral stationary (δL = 0).\nConsider a small variation in the path: \\(\\mathbf{r}(t) \\rightarrow \\mathbf{r}(t) + \\epsilon\\mathbf{\\eta}(t)\\) where \\(\\mathbf{\\eta}(t_1) = \\mathbf{\\eta}(t_2) = 0\\) (fixed endpoints). Expanding the variation of the integral to first order in ε:\n\\[\\delta L = \\frac{d}{d\\epsilon}\\bigg|_{\\epsilon=0} \\int_{t_1}^{t_2} n(\\mathbf{r}(t) + \\epsilon\\mathbf{\\eta}(t)) \\left|\\frac{d}{dt}(\\mathbf{r}(t) + \\epsilon\\mathbf{\\eta}(t))\\right| dt\\]\nUsing the chain rule and reparametrizing with arc length \\(s\\) (where \\(\\frac{d\\mathbf{r}}{ds}\\) is a unit vector), the stationarity condition leads to:\n\\[\\int_C \\left[ \\nabla n \\cdot \\mathbf{\\eta} - \\frac{d}{ds}\\left(n\\frac{d\\mathbf{r}}{ds}\\right) \\cdot \\mathbf{\\eta} \\right] ds = 0\\]\nSince this must hold for any variation \\(\\mathbf{\\eta}\\), we obtain the Euler-Lagrange equation:\n\\[\\frac{d}{ds}\\left(n\\frac{d\\mathbf{r}}{ds}\\right) = \\nabla n\\]\nThis shows that rays bend toward regions of higher refractive index, directly analogous to how a mechanical particle’s trajectory is affected by a potential field in classical mechanics.\n\n\n\n\n\n\nSELFOC Gradient Index Lens\n\n\n\n\n\nSELFOC (SELf-FOCusing) gradient-index fibers are interesting optical elements that guide light through a continuous refraction process rather than discrete refractions at interfaces. Let me demonstrate how Fermat’s principle can be used to determine the ray paths in these fibers. A SELFOC fiber has a radially varying refractive index, typically following a parabolic profile:\n\\[n(r) = n_0\\left(1 - \\frac{1}{2}\\alpha^2 r^2\\right)\\]\nwhere: - \\(n_0\\) is the refractive index at the central axis - \\(r\\) is the radial distance from the axis - \\(\\alpha\\) is the gradient constant that determines how quickly the index decreases with radius\n\n\nFor a medium with a spatially varying refractive index, Fermat’s principle states that light follows the path that minimizes the optical path length:\n\\[\\delta \\int_C n(r) ds = 0\\]\nThis yields the differential equation:\n\\[\\frac{d}{ds}\\left(n\\frac{d\\mathbf{r}}{ds}\\right) = \\nabla n\\]\n\n\n\nFor our parabolic index profile, the gradient of the refractive index is:\n\\[\\nabla n = \\frac{\\partial n}{\\partial r}\\hat{\\mathbf{r}} = -n_0\\alpha^2 r \\hat{\\mathbf{r}}\\]\nUsing cylindrical coordinates with z along the fiber axis, and assuming the paraxial approximation (rays make small angles with the z-axis), we can simplify the ray equation to:\n\\[\\frac{d^2r}{dz^2} + \\alpha^2 r = 0\\]\nThis is the equation for a harmonic oscillator, which has the solution:\n\\[r(z) = r_0 \\cos(\\alpha z) + \\frac{\\theta_0}{\\alpha} \\sin(\\alpha z)\\]\nwhere \\(r_0\\) is the initial radial position and \\(\\theta_0\\) is the initial angle of the ray with respect to the fiber axis.\n\n\nCode\n# Parameters\nn0 = 1.5  # Central refractive index\nalpha = 0.3  # Gradient constant (mm^-1)\nlength = 30  # Length of fiber (mm)\nradius = 1.5  # Radius of fiber (mm)\n\n# Create a grid for visualization\nz = np.linspace(0, length, 300)\nr_grid = np.linspace(0, radius, 100)\nZ, R = np.meshgrid(z, r_grid)\n\n# Calculate refractive index at each point\nN = n0 * (1 - 0.5 * (alpha * R)**2)\n\n# Initialize ray paths\nr0_values = [0.6, 1.0, 1.4]  # Initial radial positions\ntheta0_values = [0, 0.2, -0.2]    # Initial angles (all parallel to axis)\n\n# Plot setup\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=get_size(15, 5), gridspec_kw={'width_ratios': [3, 1]})\n\n# Plot the refractive index profile in the first subplot\ncmap = plt.cm.viridis\nextent = [0, length, -radius, radius]\nim = ax1.imshow(np.vstack((N[::-1], N)), extent=extent,\n               aspect='auto', cmap=cmap, origin='lower',alpha=0.2)\nfig.colorbar(im, ax=ax1, label='n(y)')\n\n# Plot ray paths\nfor r0, theta0 in zip(r0_values, theta0_values):\n    # Calculate ray path\n    r = r0 * np.cos(alpha * z) + (theta0/alpha) * np.sin(alpha * z)\n\n    # Plot ray path\n    ax1.plot(z, r, 'r-')\n    ax1.plot(z, -r, 'r-')  # Symmetric ray below axis\n\n# Add labels and title for first subplot\nax1.set_xlabel('z [mm]')\nax1.set_ylabel('y [mm]')\n\n# For the right subplot, plot r-position vs refractive index\n# Create a finer array of radial positions for a smooth curve\nr_positions = np.linspace(0, radius, 100)\n# Calculate refractive index at each radial position\nn_profile = n0 * (1 - 0.5 * (alpha * r_positions)**2)\n\n# Plot the refractive index profile\nax2.plot( n_profile,r_positions, 'k-')\nax2.plot( n_profile,-r_positions, 'k-')\n\n# Set labels for the index profile subplot\nax2.set_xlabel('y [mm]')\nax2.set_ylabel('n(y)')\n\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 6— Ray-path inside a SELFOC gradient index optical fiber.\n\n\n\n\n\n\n\n\n\n\n\n\nThe differential form of Fermat’s principle:\n\\[\\frac{d}{ds}\\left(n\\frac{d\\mathbf{r}}{ds}\\right) = \\nabla n\\]\nreveals a profound analogy with Newton’s Second Law of motion:\n\\[\\mathbf{F} = m\\mathbf{a} = m\\frac{d^2\\mathbf{r}}{dt^2}\\]\nThis comparison, sometimes called “F=ma optics,” illustrates how light rays follow trajectories mathematically similar to those of mechanical particles. To see this connection more clearly, we can expand the ray equation as:\n\\[n\\frac{d^2\\mathbf{r}}{ds^2} + \\frac{d\\mathbf{r}}{ds}\\frac{dn}{ds} = \\nabla n\\]\nUsing the chain rule, \\(\\frac{dn}{ds} = \\nabla n \\cdot \\frac{d\\mathbf{r}}{ds}\\), and denoting \\(\\mathbf{t} = \\frac{d\\mathbf{r}}{ds}\\) as the unit tangent vector along the ray:\n\\[n\\frac{d^2\\mathbf{r}}{ds^2} + (\\nabla n \\cdot \\mathbf{t})\\mathbf{t} = \\nabla n\\]\nRearranging to isolate the ray curvature term:\n\\[n\\frac{d^2\\mathbf{r}}{ds^2} = \\nabla n - (\\nabla n \\cdot \\mathbf{t})\\mathbf{t}\\]\nThe right side represents the component of \\(\\nabla n\\) perpendicular to the ray direction, which we can denote as \\((\\nabla n)_\\perp\\). Therefore:\n\\[\\frac{d^2\\mathbf{r}}{ds^2} = \\frac{1}{n}(\\nabla n)_\\perp\\]\nThis equation reveals that the ray curvature is proportional to the perpendicular component of the refractive index gradient and inversely proportional to the refractive index itself. Crucially, this shows that light rays bend toward regions of higher refractive index, not away from them.\nThis behavior explains many optical phenomena:\n\nLight bending toward the normal when entering a medium with higher refractive index\nLight guiding in optical fibers where light remains confined in the higher-index core\nFormation of mirages where light curves toward the denser air near the ground\nFocusing in gradient-index (GRIN) lenses where the refractive index decreases radially from the center\n\nWhile the mathematical form resembles Newton’s equation for particle motion, the analogy must be carefully interpreted: unlike particles that accelerate toward lower potential energy, light rays curve toward regions of higher refractive index.\n\n\nCode\n# Parameters\nn0 = 1.5  # Base refractive index (center value)\nn_min = 1.0  # Minimum refractive index (at edges)\nx_range = np.linspace(-5, 5, 100)\ny_range = np.linspace(-5, 5, 100)\nX, Y = np.meshgrid(x_range, y_range)\n\n# Calculate radial distance from center\nR = np.sqrt(X**2 + Y**2)\n# Max radius in our plot\nR_max = 5*np.sqrt(2)\n\n# Create a refractive index profile that decreases with radius\n# but never goes below n_min\ngradient_strength = (n0 - n_min)/R_max  # Calculate appropriate gradient strength\nn = n0 - gradient_strength * R  # Linear decrease with radius\n\n# Set up the figure\nfig, ax = plt.subplots(figsize=get_size(12, 10))\n\n# Plot the refractive index as a contour plot\ncontour = ax.contourf(X, Y, n, 20, cmap='viridis', alpha=0.3)\ncbar = fig.colorbar(contour, ax=ax, label='Refractive Index')\n\n# Calculate and plot some ray trajectories\n# We'll simulate the paths by numerical integration\n\ndef ray_path(r0, v0, steps=1000, dt=0.05):\n    \"\"\"Simulate a ray path through the medium\"\"\"\n    r = np.zeros((steps, 2))\n    v = np.zeros((steps, 2))\n    r[0] = r0\n    v[0] = v0 / np.linalg.norm(v0)  # Normalize velocity\n\n    for i in range(1, steps):\n        # Get position\n        x, y = r[i-1]\n        if abs(x) &gt;= 5 or abs(y) &gt;= 5:\n            return r[:i]\n\n        # Approximate gradient of n at this point\n        eps = 0.01\n        nx_plus = n0 - gradient_strength * np.sqrt((x+eps)**2 + y**2)\n        nx_minus = n0 - gradient_strength * np.sqrt((x-eps)**2 + y**2)\n        ny_plus = n0 - gradient_strength * np.sqrt(x**2 + (y+eps)**2)\n        ny_minus = n0 - gradient_strength * np.sqrt(x**2 + (y-eps)**2)\n\n        grad_n_x = (nx_plus - nx_minus) / (2*eps)\n        grad_n_y = (ny_plus - ny_minus) / (2*eps)\n        grad_n = np.array([grad_n_x, grad_n_y])\n\n        # Current n value\n        current_n = n0 - gradient_strength * np.sqrt(x**2 + y**2)\n\n        # Calculate the perpendicular component of gradient\n        t = v[i-1] / np.linalg.norm(v[i-1])  # Tangent vector (normalized velocity)\n        grad_n_parallel = np.dot(grad_n, t) * t  # Component along ray direction\n        grad_n_perp = grad_n - grad_n_parallel  # Perpendicular component\n\n        # Update velocity - rays bend toward higher refractive index\n        a = grad_n_perp / current_n\n        v[i] = v[i-1] + a * dt\n        v[i] = v[i] / np.linalg.norm(v[i])  # Ensure unit speed\n\n        # Update position\n        r[i] = r[i-1] + v[i] * dt\n\n    return r\n\n# Calculate several ray paths\nstart_positions = [\n    [-4, 2.5], [-4, 1.5], [-4, 0.5],\n    [-4, -0.5], [-4, -1.5], [-4, -2.5]\n]\npaths = []\n\nfor start_pos in start_positions:\n    path = ray_path(start_pos, [1, 0], steps=500)\n    paths.append(path)\n    ax.plot(path[:, 0], path[:, 1], 'r-', linewidth=1.5)\n\n# Add start points\nfor pos in start_positions:\n    ax.plot(pos[0], pos[1], 'ro')\n\n# Add axis labels\nax.set_xlabel('x position')\nax.set_ylabel('y position')\nax.set_xlim(-5, 5)\nax.set_ylim(-5, 5)\nax.set_aspect('equal')\nax.grid(True, alpha=0.3)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 7— F=ma optics - Light rays (red) following paths toward regions of higher refractive index\n\n\n\n\n\n\n\n\nLenses are among the most fundamental optical elements in photonics, using curved surfaces (typically spherical) to manipulate light paths. Understanding how lenses work requires analyzing refraction at spherical surfaces and applying this to the thin lens model.\n\n\nWhen light encounters a spherical boundary between two media, we can analyze its path using Snell’s law and geometric considerations as shown below:\n\n\n\n\n\n\nFigure 8— Refraction at a curved surface.\n\n\n\nTo determine how an image forms, we need to find where rays originating from a point at distance \\(a\\) from the surface will converge after refraction. Using Snell’s law for a ray hitting the surface at angle \\(\\alpha+\\theta_1\\):\n\\[n_{1}\\sin(\\alpha+\\theta_1)=n_{2}\\sin(\\alpha-\\theta_2)\\]\nWhere: \\[\\sin(\\alpha)=\\frac{y}{R}, \\quad \\tan(\\theta_1)=\\frac{y}{a}, \\quad \\tan(\\theta_2)=\\frac{y}{b}\\]\nFor practical optical systems, we employ the paraxial approximation, where all angles are assumed small enough that:\n\\[\\sin(\\theta) \\approx \\theta+ O(\\theta^{3}), \\quad \\tan(\\theta) \\approx \\theta + O(\\theta^{3}),\\quad \\cos(\\theta)\\approx 1 + O(\\theta^{2})\\]\nThis simplifies Snell’s law to:\n\\[n_1(\\alpha+\\theta_1)=n_2(\\alpha-\\theta_2)\\]\nAfter appropriate transformations (detailed in the online lecture), we obtain:\n\\[\\theta_2=\\frac{n_2-n_1}{n_2 R}y -\\frac{n_1}{n_2}\\theta_1\\]\nThis linear relationship between input (\\(y\\), \\(\\theta_1\\)) and output (\\(\\theta_2\\)) parameters is a hallmark of paraxial optics.\n\n\n\n\n\n\nParaxial Approximation\n\n\n\n\n\nThe paraxial approximation is a fundamental simplification in optics that assumes all angles are small. This allows us to use linear approximations for trigonometric functions, significantly simplifying calculations while maintaining accuracy for most practical scenarios involving lenses.\nTo visualize the validity of this approximation, let’s examine two plots:\n\nThe first plot compares sin(θ) (blue line) with its linear approximation θ (red dashed line) for angles ranging from 0 to π/2 radians.\nThe second plot shows the absolute error between sin(θ) and θ.\n\nThese plots demonstrate that:\n\nFor small angles (roughly up to 0.5 radians or about 30 degrees), the approximation is very close to the actual sine function.\nThe error increases rapidly for larger angles, indicating the limitations of the paraxial approximation.\n\nIn most optical systems, especially those involving lenses, the angles of incident and refracted rays are typically small enough for this approximation to be valid. However, it’s important to be aware of its limitations when dealing with wide-angle optical systems or scenarios where precision is critical.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n# Define the range of angles (in radians)\ntheta = np.linspace(0, np.pi/2, 1000)\n\n# Calculate sin(theta) and theta (linear approximation)\nsin_theta = np.sin(theta)\nlinear_approx = theta\n\n# Calculate the absolute error\nerror = np.abs(sin_theta - linear_approx)\n\n# Create the plot with two subplots side by side\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(7.5, 4))\n\n# Plot sin(theta) and theta on the first subplot\nax1.plot(theta, sin_theta, label='sin(θ)', color='blue')\nax1.plot(theta, linear_approx, label='θ', color='red', linestyle='--')\nax1.set_xlabel(r'$\\theta$ [rad]')\nax1.set_ylabel(r'$\\sin(x),x$')\nax1.legend()\n\n# Plot the error on the second subplot\nax2.plot(theta, error, label='Absolute Error', color='green')\nax2.set_xlabel(r'$\\theta$ [rad]')\nax2.set_ylabel('|sin(θ) - θ|')\nax2.legend()\n\n# Adjust the layout and display the plot\nplt.tight_layout()\nplt.show()\n\n\n\n\n\nVisualization of the paraxial approximation plotting the \\(\\sin(\\theta)\\) and the linear approximation \\(\\theta\\) (dashed line) for angles ranging from 0 to \\(\\pi/2\\) radians.\n\n\n\n\n\n\n\nTo derive the imaging equation, we analyze how light from a point object forms an image after refraction. Consider two special rays from an off-axis point:\n\n\n\n\n\n\nFigure 9— Image formation at a curved surface.\n\n\n\nFor a ray parallel to the optical axis (\\(\\theta_1=0\\)):\n\\[\\theta_2=\\frac{n_2-n_1}{n_2}\\frac{y}{R}=\\frac{y+\\Delta y}{b}\\]\nFor a ray through the center of curvature (\\(y=0\\)):\n\\[n_2\\frac{\\Delta y}{b}=n_1\\frac{y}{a}\\]\nCombining these equations yields the fundamental imaging equation for a spherical surface:\n\\[\\frac{n_1}{a}+\\frac{n_2}{b}=\\frac{n_2-n_1}{R}\\]\nFrom this, we define the focal length of the spherical surface:\n\\[f=\\frac{n_2}{n_2-n_1}R\\]\n\n\n\n\n\n\nImaging Equation for Spherical Refracting Surface\n\n\n\nThe sum of the inverse object and image distances equals the inverse focal length of the spherical refracting surface:\n\\[\\frac{n_1}{a}+\\frac{n_2}{b}\\approx\\frac{n_2}{f}\\]\nwhere the focal length of the refracting surface is given by:\n\\[f=\\frac{n_2}{n_2-n_1}R\\]\nin the paraxial approximation.\n\n\n\n\n\n\nA lens consists of two spherical surfaces in close proximity. To analyze how a lens forms images, we consider refraction at both surfaces:\n\n\n\n\n\n\nFigure 10— Refraction on two spherical surfaces.\n\n\n\nWhen the lens thickness \\(d\\) is much smaller than the radii of curvature (\\(d \\ll R_1, R_2\\)), we can apply the thin lens approximation. This assumes: 1. The ray height at both surfaces is approximately equal (\\(y \\approx y'\\)) 2. All refraction effectively occurs at a single plane (the principal plane) 3. The change in angle is additive from both surfaces\nThis approximation, combined with the sign convention for radii (positive for convex surfaces facing incoming light, negative for concave), leads to the thin lens formula:\n\n\n\n\n\n\nImaging Equation for Thin Lens\n\n\n\nThe sum of the inverse object and image distances equals the inverse focal length of the thin lens:\n\\[\\frac{1}{a}+\\frac{1}{b}=\\frac{1}{f}\\]\nwhere:\n\\[\\frac{1}{f}=\\frac{n_2-n_1}{n_1}\\left(\\frac{1}{R_1}-\\frac{1}{R_2}\\right)\\]\n\n\nThis can be rearranged to give the lensmaker equation:\n\n\n\n\n\n\nLensmaker Equation\n\n\n\nThe focal length of a thin lens is calculated by: \\[f=\\frac{n_1}{n_2-n_1}\\left(\\frac{R_1 R_2}{R_2-R_1}\\right)\\]\nin the paraxial approximation.\n\n\n\n\nTo construct the image formed by a lens, we typically trace two or three special rays: 1. A ray parallel to the optical axis, which passes through the far focal point after refraction 2. A ray through the center of the lens, which passes undeflected 3. A ray through the near focal point, which emerges parallel to the optical axis\nThe intersection of these rays locates the image position:\n\n\n\n\n\n\nFigure 11— Image construction on a thin lens.\n\n\n\nThe ratio of image height to object height defines the magnification:\n\n\n\n\n\n\nMagnification of a Lens\n\n\n\nThe magnification is given by:\n\\[M=\\frac{h_{\\rm image}}{h_{\\rm object}}=-\\frac{b}{a}=\\frac{f}{f-a}\\]\nwhere the negative sign indicates image inversion for real images.\n\n\nThe image characteristics depend on the object distance relative to the focal length:\n\n\n\n\n\n\n\n\n\nObject Position\nImage Characteristics\nMagnification (M)\nImage Type\n\n\n\n\n\\(a &lt; f\\)\nUpright and magnified\n\\(M &gt; 0\\)\nVirtual\n\n\n\\(f &lt; a &lt; 2f\\)\nInverted and magnified\n\\(M &lt; -1\\)\nReal\n\n\n\\(a = 2f\\)\nInverted, same size\n\\(M = -1\\)\nReal\n\n\n\\(a &gt; 2f\\)\nInverted and reduced\n\\(-1 &lt; M &lt; 0\\)\nReal\n\n\n\\(a = f\\)\nImage at infinity\n\\(M = \\infty\\)\n-\n\n\n\nThe diagram below illustrates these various imaging scenarios for a biconvex lens:\n\n\n\n\n\n\n\n\n\n\n\nFig.: Image construction on a biconvex lens with a parallel and a central ray for different object distances.\n\n\n\n\n\n\n\n\n\nMatrix Optics\n\n\n\n\n\nThe above derived equations for a single spherical surface yield a linear relation between the input variables \\(y_1\\) and \\(\\theta_1\\) and the output variables \\(y_2\\) and \\(\\theta_2\\). The linear relation yields a great opportunity to express optical elements in terms of linear transformations (matrices). This is the basis of matrix optics. The matrix representation of a lens is given by\n\\[\\begin{pmatrix} y_2 \\\\ \\theta_2 \\end{pmatrix} = \\begin{pmatrix} 1 & 0 \\\\ -\\frac{1}{f} & 1 \\end{pmatrix} \\begin{pmatrix} y_1 \\\\ \\theta_1 \\end{pmatrix}\\]\nwhere the matrix is called the ABCD matrix of the lens. Due to the linearization of Snells law w can write down more generally\n\\[\\begin{pmatrix} y_2 \\\\\n\\theta_2 \\end{pmatrix} = \\begin{pmatrix} A & B \\\\ C & D \\end{pmatrix} \\begin{pmatrix} y_1 \\\\ \\theta_1 \\end{pmatrix}\\]\nand one can obtain a Matrix for all types of optical elements such as free space of dustance \\(d\\).\n\\[\\begin{bmatrix}\nA & B\\\\\nC & D\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1 & d\\\\\n0 & 1\n\\end{bmatrix}\n\\]\nHere are some useful matrices for optical elements:\n\\[\n\\mathbf{M}=\\left[\\begin{array}{ll}\n1 & d \\\\\n0 & 1\n\\end{array}\\right] \\tag{Free space}\n\\]\n\\[\n\\mathbf{M}=\\left[\\begin{array}{cc}\n1 & 0 \\\\\n0 & \\frac{n_1}{n_2}\n\\end{array}\\right] \\tag{Planar interface}\n\\]\n\\[\n\\mathbf{M}=\\left[\\begin{array}{cc}\n1 & 0 \\\\\n-\\frac{\\left(n_2-n_1\\right)}{n_2 R} & \\frac{n_1}{n_2}\n\\end{array}\\right] \\tag{Spherical Boundary}\n\\]\n\\[\n\\mathbf{M}=\\left[\\begin{array}{cc}\n1 & 0 \\\\\n-\\frac{1}{f} & 1\n\\end{array}\\right] \\tag{Tin Lens}\n\\]\nIf we have now a system of optical elements, we can multiply the matrices of the individual elements to obtain the matrix of the whole system.\n\\[\n\\rightarrow \\mathrm{M}_1 \\rightarrow \\mathrm{M}_2 \\rightarrow \\mathrm{M}_N \\rightarrow \\mathrm{M}=\\mathbf{M}_N \\ldots \\mathrm{M}_2 \\mathbf{M}_1 \\text {. }\n\\]\nThis is a very powerful tool to analyze optical systems.",
    "crumbs": [
      "Home",
      "FOUNDATIONS OF PHOTONICS",
      "Lecture 1",
      "Ray Optics"
    ]
  },
  {
    "objectID": "lectures/lecture01/01-lecture01.html#fermats-principle-for-spherical-surfaces",
    "href": "lectures/lecture01/01-lecture01.html#fermats-principle-for-spherical-surfaces",
    "title": "Photonics",
    "section": "Fermat’s Principle for Spherical Surfaces",
    "text": "Fermat’s Principle for Spherical Surfaces\nThe power of Fermat’s principle becomes particularly evident when applied to spherical refracting surfaces. Consider a spherical boundary of radius \\(R\\) between two media with refractive indices \\(n_1\\) and \\(n_2\\). According to Fermat’s principle, light will follow the path that minimizes the total optical path length.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Arc, Wedge\nimport matplotlib.patches as patches\n\n# Set up the figure\nfig, ax = plt.subplots(figsize=get_size(15, 10))\n\n# Parameters\nR = 3  # Radius of the spherical surface\nn1 = 1.0  # Refractive index of first medium\nn2 = 1.5  # Refractive index of second medium\narc_angle = 100  # Arc angle in degrees\ncenter_x = 3  # Center of arc is to the right of the boundary\n\n# Define the center of the sphere\ncenter = (center_x, 0)\n\n# Calculate arc angles in radians\nstart_angle = 180 - arc_angle/2\nend_angle = 180 + arc_angle/2\n\n# Draw the spherical surface as an arc\narc = Arc(center, 2*R, 2*R, theta1=start_angle, theta2=end_angle,\n          color='black', linewidth=1.5)\nax.add_patch(arc)\n\n# Calculate the x-coordinate of the leftmost point of the arc\nboundary_x = center_x - R * np.cos(np.radians(90 - arc_angle/2))\n\n# Draw the media boundary\nax.fill_between([-8, boundary_x], [-8, -8], [8, 8], color='lightblue', alpha=0.2)\nax.fill_between([boundary_x, 12], [-8, -8], [8, 8], color='lightgreen', alpha=0.2)\nax.axvline(x=boundary_x, color='black', linestyle='-', linewidth=1)\n\n# Add labels for the media\nax.text(boundary_x-3, 3, f\"n₁ = {n1}\", fontsize=12)\nax.text(boundary_x+2, 3, f\"n₂ = {n2}\", fontsize=12)\n\n# Mark object and image points\nobject_point = (boundary_x-3, 0)\nimage_point = (center_x+6, 0)\nax.plot(object_point[0], object_point[1], 'bo', markersize=8, label='Object (A)')\nax.plot(image_point[0], image_point[1], 'ro', markersize=8, label='Image (B)')\n\n# Calculate different potential paths along the arc\ntheta_rad = np.linspace(np.radians(start_angle), np.radians(end_angle), 15)\npaths = []\noptical_lengths = []\n\nfor theta in theta_rad:\n    # Position on the arc\n    x = center_x + R * np.cos(theta)\n    y = R * np.sin(theta)\n\n    # Calculate distances\n    d1 = np.sqrt((x - object_point[0])**2 + (y - object_point[1])**2)\n    d2 = np.sqrt((x - image_point[0])**2 + (y - image_point[1])**2)\n\n    # Calculate optical path length\n    optical_length = n1 * d1 + n2 * d2\n\n    paths.append((x, y))\n    optical_lengths.append(optical_length)\n\n# Find the minimum optical path\nmin_index = np.argmin(optical_lengths)\nmin_path = paths[min_index]\n\n# Plot all potential paths\nfor i, (x, y) in enumerate(paths):\n    if i == min_index:\n        continue\n    ax.plot([object_point[0], x, image_point[0]], [object_point[1], y, image_point[1]],\n             'gray', linestyle='--', alpha=0.5, linewidth=0.8)\n\n# Plot the path of minimum optical length (Fermat's principle)\nax.plot([object_point[0], min_path[0], image_point[0]], [object_point[1], min_path[1], image_point[1]],\n         'red', linewidth=2, label='Minimum optical path')\n\n\n# Set up the main plot\nax.set_xlim(-4, 12)\nax.set_ylim(-4, 4)\nax.set_xlabel('Position')\nax.set_ylabel('Height')\nax.grid(True, alpha=0.3)\nax.axhline(y=0, color='gray', linestyle='--', alpha=0.7)\nax.legend(loc='lower right')\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 12— Fermat’s principle applied to a spherical refracting surface\n\n\n\n\n\nWhen we apply Fermat’s principle to a spherical surface, we can derive the laws of refraction. Consider a spherical boundary between two media with refractive indices \\(n_1\\) and \\(n_2\\). We’ll place our coordinate system so that the spherical surface intersects the x-axis at x=0, with radius R and its center at position (R,0) to the right.\nFor a point P on the spherical surface at height y from the optical axis, the total optical path length from object point A at (-a,0) to image point B at (b,0) is:\n\\[L = n_1|AP| + n_2|PB|\\]\nwhere: \\[|AP| = \\sqrt{a^2 + y^2}\\] \\[|PB| = \\sqrt{b^2 + y^2}\\]\nAccording to Fermat’s principle, light follows the path where this length is stationary:\n\\[\\frac{dL}{dy} = n_1\\frac{d|AP|}{dy} + n_2\\frac{d|PB|}{dy} = 0\\]\nComputing these derivatives:\n\\[\\frac{d|AP|}{dy} = \\frac{y}{|AP|}\\] \\[\\frac{d|PB|}{dy} = \\frac{y}{|PB|}\\]\nSubstituting into our condition:\n\\[n_1\\frac{y}{|AP|} + n_2\\frac{y}{|PB|} = 0\\]\nThis equation is incorrect. The right-hand side should not be zero because we need to account for the geometry of the spherical surface. The correct form includes the effect of the surface normal:\n\\[n_1\\frac{y}{|AP|} + n_2\\frac{y}{|PB|} = \\frac{(n_2-n_1)y}{R}\\]\nThis correction comes from the fact that at point P, the normal to the spherical surface makes an angle α with the optical axis, where sin(α) ≈ y/R in the paraxial approximation.\nDividing by y (assuming y≠0):\n\\[\\frac{n_1}{|AP|} + \\frac{n_2}{|PB|} = \\frac{n_2-n_1}{R}\\]\nIn the paraxial approximation, we can use |AP| ≈ a and |PB| ≈ b, yielding:\n\\[\\frac{n_1}{a} + \\frac{n_2}{b} = \\frac{n_2-n_1}{R}\\]\nThis is the correct imaging equation for a spherical refracting surface.\nThe elegance of Fermat’s principle is preserved, as it still naturally produces the same result as our geometric derivation, once we properly account for the geometry of the refracting surface.\n\n\n\n\n\n\nDeriving the Thin Lens Equation from Fermat’s Principle\n\n\n\n\n\nTo derive the thin lens equation, we apply Fermat’s principle to the two spherical surfaces that make up a lens. Consider a lens with refractive index \\(n_2\\) in a medium of index \\(n_1\\), with surface radii \\(R_1\\) and \\(R_2\\).\nThe total optical path for a ray passing through the lens at height \\(y\\) from the optical axis is: - Path from object to first surface: \\(n_1 s_1\\) - Path through the lens: \\(n_2 s_2\\) - Path from second surface to image: \\(n_1 s_3\\)\nFor a thin lens, the optical path length simplifies to:\n\\[L(y) = n_1 \\sqrt{a^2 + y^2} + n_2 d(y) + n_1 \\sqrt{b^2 + y^2}\\]\nWhere \\(d(y)\\) is the thickness of the lens at height \\(y\\), which can be approximated as:\n\\[d(y) \\approx d_0 + \\frac{y^2}{2}\\left(\\frac{1}{R_1}-\\frac{1}{R_2}\\right)\\]\nApplying Fermat’s principle (\\(\\frac{dL}{dy} = 0\\)) and using the paraxial approximation:\n\\[\\frac{n_1 y}{\\sqrt{a^2 + y^2}} + n_2 y \\left(\\frac{1}{R_1}-\\frac{1}{R_2}\\right) + \\frac{n_1 y}{\\sqrt{b^2 + y^2}} = 0\\]\nIn the paraxial limit (\\(y \\ll a, y \\ll b\\)), this becomes:\n\\[\\frac{n_1 y}{a} + n_2 y \\left(\\frac{1}{R_1}-\\frac{1}{R_2}\\right) + \\frac{n_1 y}{b} = 0\\]\nDividing by \\(y\\) and rearranging:\n\\[\\frac{1}{a} + \\frac{1}{b} = \\frac{n_2-n_1}{n_1}\\left(\\frac{1}{R_1}-\\frac{1}{R_2}\\right) = \\frac{1}{f}\\]\nThis is the thin lens equation with the focal length given by the lensmaker’s equation:\n\\[f = \\frac{n_1}{n_2-n_1}\\left(\\frac{R_1 R_2}{R_2-R_1}\\right)\\]\nThus, both the imaging equation and the lensmaker equation emerge naturally from Fermat’s principle applied to the geometry of a thin lens, showing that light follows paths of equal optical length from object to image when passing through any part of the lens.\nFrom a wave perspective, what makes a lens focus light to a point is that all paths from object to image through any part of the lens have equal optical path lengths (to first order in the paraxial approximation), ensuring constructive interference at the image point.",
    "crumbs": [
      "Home",
      "FOUNDATIONS OF PHOTONICS",
      "Lecture 1",
      "Ray Optics"
    ]
  }
]