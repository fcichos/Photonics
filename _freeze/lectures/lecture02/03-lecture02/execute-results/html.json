{
  "hash": "b87ea9a5310a91f62f0e82065753cf25",
  "result": {
    "engine": "jupyter",
    "markdown": "---\njupyter: python3\nformat:\n  html:\n    code-fold: true\ncrossref:\n  fig-title: Figure\n  tbl-title: Tbl\n  title-delim: —\n  fig-prefix: Figure\n  eq-prefix: Eq.\n  chapters: true\ntitle: Interference in space and time\n---\n\n\n\n\n\n\n\nInterference is a fundamental physical phenomenon that demonstrates the superposition principle for linear systems. This principle, which states that the net response to multiple stimuli is the sum of the individual responses, is central to our understanding of wave physics. Interference appears across many domains of physics: in optics where it enables high-precision measurements and holography, in quantum mechanics where it reveals the wave nature of matter, and in acoustics where it forms the basis for noise cancellation technology. The ability of waves to interfere constructively (amplifying each other) or destructively (canceling each other) has profound practical applications, from the anti-reflective coatings on optical elements to the operational principles of interferometric gravitational wave detectors like LIGO. Understanding interference is therefore not just of theoretical interest but crucial for modern technology and experimental physics.\n\n\nWhen two wave solutions $U_1(\\mathbf{r})$ and $U_2(\\mathbf{r})$ combine, their superposition gives:\n\n$$\nU(\\mathbf{r})=U_1(\\mathbf{r})+U_2(\\mathbf{r})\n$$\n\nThe resulting intensity is:\n\n\\begin{eqnarray}\nI &= &|U|^2\\\\\n&= &|U_1+U_2|^2\\\\\n&= &|U_1|^2+|U_2|^2+U^{*}_1 U_2 + U_1 U^{*}_2\n\\end{eqnarray}\n\nThe individual wave intensities are given by $I_1=|U_1|^2$ and $I_2=|U_2|^2$. Using this, we can express each complex wave amplitude in polar form, separating its magnitude (related to intensity) and phase:\n\n$$\nU_1=\\sqrt{I_1}e^{i\\phi_1}\n$$\n$$\nU_2=\\sqrt{I_2}e^{i\\phi_2}\n$$\n\nSubstituting these expressions back into our interference equation and performing the algebra, the total intensity becomes:\n\n$$\nI=I_1+I_2+2\\sqrt{I_1 I_2}\\cos(\\Delta \\phi)\n$$\n\nwhere $\\Delta \\phi=\\phi_2-\\phi_1$ is the phase difference between the waves. This equation is known as the interference formula and contains three terms:\n\n- $I_1$ and $I_2$: the individual intensities\n- $2\\sqrt{I_1 I_2}\\cos(\\Delta \\phi)$: the interference term that can be positive or negative\n\nA particularly important special case occurs when the interfering waves have equal intensities ($I_1=I_2=I_0$). The equation then simplifies to:\n\n$$\nI=2I_0(1+\\cos(\\Delta \\phi))=4I_0\\cos^2\\left(\\frac{\\Delta \\phi}{2}\\right)\n$$\n\nThis last form clearly shows that:\n\n- Maximum intensity ($4I_0$) occurs when $\\Delta \\phi = 2\\pi n$ (constructive interference)\n- Zero intensity occurs when $\\Delta \\phi = (2n+1)\\pi$ (destructive interference)\n- The intensity varies sinusoidally with the phase difference\n\n\n::: {.callout-note}\n### Constructive Interference\nOccurs when $\\Delta \\phi=2\\pi m$ (where $m$ is an integer), resulting in $I=4I_0$\n:::\n\n\n::: {#3ee370d3 .cell execution_count=2}\n``` {.python .cell-code code-fold=\"true\"}\nx=np.linspace(0,2,1000)\nwavelength=0.532\nk=2*np.pi/0.532\ny1=np.cos(k*x)\n\nfig,[ax1,ax2,ax3]=plt.subplots(3,1,figsize=get_size(10,8))\nax1.plot(x/wavelength,y1,label='Wave 1')\nax2.plot(x/wavelength,y1,label='Wave 1')\nax3.plot(x/wavelength,2*y1,label='Wave 1')\nax3.set_xlabel(r\"distance [$\\lambda$]\")\nax1.set_ylabel(r\"$U_1$\")\nax2.set_ylabel(r\"$U_2$\")\nax3.set_ylabel(r\"$U_1+U_2$\")\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Constructive interference of two waves (top, middle) and the sum of the two wave amplitudes (bottom)](03-lecture02_files/figure-html/cell-3-output-1.png){width=368 height=291 fig-align='center'}\n:::\n:::\n\n\n::: {.callout-note}\n### Destructive Interference\nOccurs when $\\Delta \\phi=(2m-1)\\pi$ (where $m$ is an integer), resulting in $I=0$\n:::\n\n::: {#1a319491 .cell execution_count=3}\n``` {.python .cell-code code-fold=\"true\"}\nx=np.linspace(0,2,1000)\nwavelength=0.532\nk=2*np.pi/0.532\ny1=np.cos(k*x)\ny2=np.cos(k*x+np.pi)\n\nfig,[ax1,ax2,ax3]=plt.subplots(3,1,figsize=get_size(10,8))\nax1.plot(x/wavelength,y1,label='Wave 1')\nax2.plot(x/wavelength,y2,label='Wave 1')\nax3.plot(x/wavelength,y1+y2,label='Wave 1')\nax3.set_xlabel(r\"distance [$\\lambda$]\")\nax1.set_ylabel(r\"$U_1$\")\nax2.set_ylabel(r\"$U_2$\")\nax3.set_ylabel(r\"$U_1+U_2$\")\nax3.set_ylim(-1,1)\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Destructive interference of two waves (top, middle) and the sum of the two wave amplitudes (bottom)](03-lecture02_files/figure-html/cell-4-output-1.png){width=368 height=291 fig-align='center'}\n:::\n:::\n\n\n### Phase and Path Difference\n\nThe phase difference $\\Delta \\phi$ can be related to the path difference $\\Delta s$ between the two waves. For two waves with the same frequency $\\omega$, we can write their complete phase expressions as:\n\n$$\\phi_1(\\mathbf{r},t) = \\mathbf{k}_1\\cdot\\mathbf{r} - \\omega t + \\phi_{01}$$\n$$\\phi_2(\\mathbf{r},t) = \\mathbf{k}_2\\cdot\\mathbf{r} - \\omega t + \\phi_{02}$$\n\nwhere:\n\n- $\\mathbf{k}_i$ are the wave vectors\n- $\\mathbf{r}$ is the position vector\n- $\\omega$ is the angular frequency\n- $\\phi_{0i}$ are initial phase constants\n\nThe instantaneous phase difference is then:\n\n$$\n\\Delta\\phi(\\mathbf{r},t) = \\phi_2(\\mathbf{r},t) - \\phi_1(\\mathbf{r},t) = (\\mathbf{k}_2-\\mathbf{k}_1)\\cdot\\mathbf{r} + (\\phi_{02}-\\phi_{01})\n$$\n\nFor stationary interference patterns, we typically observe the time-independent phase difference. When the waves travel along similar paths (same direction), this reduces to:\n\n$$\\Delta\\phi = k\\Delta s + \\Delta\\phi_0$$\n\nwhere $\\Delta s$ is the path difference and $\\Delta\\phi_0$ is any initial phase difference between the sources.\n\n\n::: {.callout-important}\n### Phase Difference and Path Difference\nA path difference $\\Delta s$ corresponds to a phase difference $k\\Delta s=2\\pi\\Delta s/\\lambda$. Path differences of integer multiples of $\\lambda$ result in phase differences of integer multiples of $2\\pi$.\n:::\n\n\n### Interference of Waves in Space\n\n::: {#12eb1936 .cell execution_count=4}\n``` {.python .cell-code code-fold=\"true\"}\ndef plane_wave(k,omega,r,t):\n    return(np.exp(1j*(np.dot(k,r)-omega*t)))\n\nwavelength=532e-9\nk0=2*np.pi/wavelength\nc=299792458\nomega0=k0*c\n\nvec=np.array([0.0,0.,1.])\nvec1=np.array([1.0,0.,1.])\nvec=vec/np.sqrt(np.dot(vec,vec))\nvec1=vec1/np.sqrt(np.dot(vec1,vec1))\n\nk=k0*vec\nk1=k0*vec1\n\nx=np.linspace(-2.5e-6,2.5e-6,300)\nz=np.linspace(0,5e-6,300)\n\nX,Z=np.meshgrid(x,z)\nr=np.array([X,0,Z],dtype=object)\n\nfig,ax=plt.subplots(2,2,figsize=get_size(10,10))\nfield=plane_wave(k,omega0,r,0)\nfield1=plane_wave(k1,omega0,r,0)\n\nextent = np.min(z)*1e6, np.max(z)*1e6,np.min(x)*1e6, np.max(x)*1e6\nax[0,0].imshow(np.real(field.transpose()),extent=extent,vmin=-1,vmax=1,cmap='seismic')\nax[0,0].set_title('wave 1')\nax[0,1].imshow(np.real(field1.transpose()),extent=extent,vmin=-1,vmax=1,cmap='seismic')\nax[0,1].set_title('wave 2')\nax[1,0].imshow(np.real(field.transpose()+field1.transpose()),extent=extent,vmin=-1,vmax=1,cmap='seismic')\nax[1,0].set_title('sum')\nax[1,1].imshow(np.abs(field.transpose()+field1.transpose())**2,extent=extent,cmap='gray')\nax[1,1].set_title('intensity')\nax[1,1].set_xlabel('z-position [µm]')\nax[1,0].set_xlabel('z-position [µm]')\nax[1,0].set_ylabel('x-position [µm]')\nax[0,0].set_ylabel('x-position [µm]')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Interference of two plane waves propagating under an angle of 45°. The two left graphs show the original waves. The two right show the total amplitude and the intensity pattern.](03-lecture02_files/figure-html/cell-5-output-1.png){width=357 height=367 fig-align='center'}\n:::\n:::\n\n\n::: {#0abc6159 .cell execution_count=5}\n``` {.python .cell-code code-fold=\"true\"}\ndef spherical_wave(k,omega,r,r0,t):\n    k=np.linalg.norm(k)\n    d=np.linalg.norm(r-r0)\n    return( np.exp(1j*(k*d-omega*t))/d)\n\n\n\nx=np.linspace(-5e-6,5e-6,300)\nz=np.linspace(-5e-6,5e-6,300)\n\nX,Z=np.meshgrid(x,z)\nr=np.array([X,0,Z],dtype=object)\n\nwavelength=532e-9\nk0=2*np.pi/wavelength\nc=299792458\nomega0=k0*c\n\nk=k0*np.array([0,1.0,0])\nr0=np.array([0,2e-6,0])\n\nfield=spherical_wave(k,omega0,r,r0,0)\nfield1=plane_wave(k,omega0,r,0)\n\nextent = np.min(z)*1e6, np.max(z)*1e6,np.min(x)*1e6, np.max(x)*1e6\n\nfig,ax=plt.subplots(2,2,figsize=get_size(10,10))\nax[0,0].imshow(np.real(field.transpose()+0*field1.transpose()),extent=extent,cmap='seismic')\nax[0,0].set_title('Spherical wave')\nax[0,1].imshow(np.real(0*field.transpose()+field1.transpose()),extent=extent,cmap='seismic')\nax[0,1].set_title('Plane wave')\nax[1,0].imshow(np.real(0.00001*field.transpose()+field1.transpose()),extent=extent,cmap='seismic')\nax[0,1].set_title('Sum')\nax[1,1].imshow(np.abs(0.00001*field.transpose()+field1.transpose())**2,extent=extent,cmap='gray')\nax[0,1].set_title('Intensity')\nax[1,0].set_xlabel('z [µm]')\nax[1,1].set_xlabel('z [µm]')\nax[1,0].set_ylabel('x [µm]')\nax[0,0].set_ylabel('x [µm]')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Interference of a spherical wave and a plane wave. The top graphs show the original waves. The two bottom show the total amplitude and the intensity pattern.](03-lecture02_files/figure-html/cell-6-output-1.png){width=350 height=356 fig-align='center'}\n:::\n:::\n\n\nThe interference of the spherical and the plane wave (also the one of the two plane waves) give also an interesting result. The intensity resembles to be a snapshot of the shape of the wavefronts of the spherical wave. We can therefore measure the wavefronts of the spherical wave by interfering it with a plane wave. This is also the basic principle behind holography. There we use a reference wave to interfere with the wave that we want to measure. The interference pattern is recorded and can be used to reconstruct the wavefronts of the wave.\n\n::: {.callout-alert}\nA super nice website to try out interference interactively is [here](https://www.falstad.com/ripple/).\n:::\n\n### Coherence\n\nIn the earlier consideration we obtained a general description for the phase difference between two waves. TIt is given by and contains the pathlength difference $\\Delta s$ and some intrinsic phase  $\\Delta\\phi_0$ that could be part of the wave generation process.\n\n$$\\Delta\\phi = k\\Delta s + \\Delta\\phi_0$$\n\nTo observe stationary interference, it is important that these two quantities are also stationary, i.e. the phase relation between the two waves is stationary. This relation between the phase of two waves is called coherence and was assumed in all the examples before.\n\n![Two waves of different frequency over time.](img/coherence.png){width=\"90%\" fig-align=\"center\"}\n\nThe above image shows the timetrace of the amplitude of two wave with slightly different frequency. Due to the frequency, the waves run out of phase and have acquired a phase different of $\\pi$ after $40$ fs.\n\nThe temporal coherence of two waves is now defined by the time it takes for the two waves to obtain a phase difference of $2\\pi$. The phase difference between two wave of frequency $\\nu_1$ and $\\nu_2$ is given by\n\n$$\n\\Delta \\phi = 2\\pi (\\nu_2-\\nu_1)(t-t_0)\n$$\n\nHere $t_0$ refers to the time, when thw two waves were perfectly in sync. Lets assume that the two frequencies are seperarated from a central frequency $\\nu_0$ such that\n\n$$\n\\nu_1=\\nu_0-\\Delta \\nu/2\n$$\n$$\n\\nu_2=\\nu_0+\\Delta \\nu/2\n$$\n\nInserting this into the first equation yields\n\n$$\n\\Delta \\phi = 2\\pi \\Delta \\nu \\Delta t\n$$\n\nwith $\\Delta t=t-t_0$. We can now define the coherence time as the time interval over which the phase shift $\\Delta \\phi$ grows to $2\\pi$, i.e. $\\Delta \\phi=2\\pi$. The coherence time is thus\n\n$$\n\\tau_{c}=\\Delta t =\\frac{1}{\\Delta \\nu}\n$$\n\nThus the temporal coherence and the frequency distribution of the light are intrisincly connected. Monochromatic light has $\\Delta nu=0$ and thus the coherence time is infinitely long. Light with a wide spectrum (white light for example) therefore has and extremly short coherence time.\n\nThe coherence time is also connected to a coherence length. The coherence length $L_c$ is given by the distance light travels within the coherence time $\\tau_c$, i.e.\n\n$$\nL_c=c\\tau_c\n$$\n\n::: {.callout-note }\n## Coherence\n\nTwo waves are called coherent, if they exihibit a fixed phase relation in space or time relation over time. It measures their ability to interfer. The main types of coherence are\n\n### Temporal Coherence\n- Measures phase correlation of a wave with itself at different times\n- Characterized by coherence time $\\tau_c$ and coherence length $L_c = c\\tau_c$\n- Related to spectral width: $\\tau_c = 1/\\Delta\\nu$\n- Perfect for monochromatic waves (single frequency)\n- Limited for broad spectrum sources (like thermal light)\n\n### Spatial Coherence\n- Measures phase correlation between different points in space\n- Important for interference from extended sources\n- Determines ability to form interference patterns\n- Related to source size and geometry\n\nCoherence is a property of the light source and is connected to the frequency distribution of the light.\nSources can be:\n\n- **Fully coherent**: ideal laser\n- **Partially coherent**: real laser\n- **Incoherent**: thermal light\n:::\n\n\n::: {.callout-note collapse=true}\n### More General Description of Coherence\n\nWhile the above definition provides an intuitive picture based on frequency spread, we can describe coherence more rigorously using correlation functions. These functions measure how well a wave maintains its phase relationships:\n\nIn real physical systems, perfect coherence (constant phase relationship) between waves is rare. Partial coherence describes the degree to which waves maintain a consistent phase relationship over time and space. We can characterize this using correlation functions:\n\n1. **Temporal Coherence**\nThe complex degree of temporal coherence is given by:\n\n$$g^{(1)}(\\tau) = \\frac{\\langle U(t)U^*(t+\\tau)\\rangle}{\\sqrt{\\langle|U(t)|^2\\rangle\\langle|U(t+\\tau)|^2\\rangle}}$$\n\nwhere:\n\n- $\\tau$ is the time delay\n- $U(t)$ is the electric field\n- $\\langle...\\rangle$ denotes time averaging\n\n2. **Spatial Coherence**\nSimilarly, spatial coherence between two points is characterized by:\n\n$$g^{(1)}(\\mathbf{r}_1,\\mathbf{r}_2) = \\frac{\\langle U(\\mathbf{r}_1)U^*(\\mathbf{r}_2)\\rangle}{\\sqrt{\\langle|U(\\mathbf{r}_1)|^2\\rangle\\langle|U(\\mathbf{r}_2)|^2\\rangle}}$$\n\nThe obtained correlation functions can be used to calculate the coherence time and length and have the following properties:\n\n- $|g^{(1)}| = 1$ indicates perfect coherence\n- $|g^{(1)}| = 0$ indicates complete incoherence\n- $0 < |g^{(1)}| < 1$ indicates partial coherence\n\nA finite coherence time and length is leads to partial coherence affects interference visibility through:\n\n- Reduced contrast in interference patterns\n- Limited coherence length/area\n- Spectral broadening\n\n::: {#be756016 .cell execution_count=6}\n``` {.python .cell-code code-fold=\"true\"}\nomega0 = 2.0\ndelta_omega = 0.05  # frequency difference\ntau_c = np.pi/delta_omega  # coherence time (corrected)\nbeat_period = 2*np.pi/delta_omega  # time for full beat cycle\n\nt = np.linspace(0, 1000, 10000)\ntau = np.linspace(0, 500, 200)\n\ndef generate_waves(t):\n    wave1 = np.exp(1j * omega0 * t)\n    wave2 = np.exp(1j * (omega0 + delta_omega) * t)\n    return wave1, wave2\n\ndef calc_correlation(wave, tau):\n    g = np.zeros(len(tau), dtype=complex)\n    N = len(wave)\n\n    for i, dt in enumerate(tau):\n        shift = int(dt * 10)\n        if shift >= N:\n            g[i] = 0\n        else:\n            g[i] = np.mean(wave[:(N-shift)] * np.conj(wave[shift:]))\n\n    return g / np.abs(g[0])\n\n\nwave1, wave2 = generate_waves(t)\nwave_total = wave1 + wave2\n\n# Calculate correlation\ng = calc_correlation(wave_total, tau)\n\n# Plot\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=get_size(10, 8))\n\n# Plot waves\nax1.plot(t[:500], np.real(wave1[:500]), label='Wave 1', alpha=0.7)\nax1.plot(t[:500], np.real(wave2[:500]), label='Wave 2', alpha=0.7)\nax1.plot(t[:500], np.real(wave_total[:500]), 'k', label='Sum', alpha=0.7,lw=0.5)\nax1.set_title('wave superposition')\nax1.set_xlabel('time')\nax1.set_ylabel('amplitude')\nax1.legend(bbox_to_anchor=(1.05, 1), loc='upper left')\n\n\n# Plot correlation\nax2.plot(tau, np.abs(g))\nax2.axvline(x=tau_c, color='r', linestyle='--', label=r'$\\tau_c$ ')\nax2.axvline(x=beat_period, color='g', linestyle=':', label=f'Beat period')\nax2.set_title('|g⁽¹⁾(τ)|')\nax2.set_xlabel('τ')\nax2.set_ylabel('|g⁽¹⁾(τ)|')\nax2.legend(bbox_to_anchor=(1.05, 1), loc='upper left')\nplt.tight_layout()\nplt.subplots_adjust(right=0.85)\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Temporal correlation for two waves with slightly different frequencies. The vertical line indicates the coherence time τc = π/Δω.](03-lecture02_files/figure-html/cell-7-output-1.png){width=446 height=292 fig-align='center'}\n:::\n:::\n\n\nBesides different frequencies the coherence time can also be affected by phase jumps. The following example shows two waves with the same frequency but multiple phase jumps. The temporal correlation function shows the decoherence due to the phase jumps.\n\n::: {#d493b4e1 .cell execution_count=7}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nomega0 = 1.0  # same frequency for both waves\ntau = np.linspace(0, 500, 200)\n\nt = np.linspace(0, 1000, 10000)\n\ndef generate_waves_with_jumps(t, n_jumps=10):\n    # Create two identical waves\n    wave1 = np.exp(1j * omega0 * t)\n    wave2 = np.exp(1j * omega0 * t)  # same frequency\n\n    # Create regularly spaced jumps within first 500 time units\n    jump_positions = np.linspace(0, 500, n_jumps+1)[:-1]  # exclude last point\n    jump_indices = [int(pos * len(t)/t[-1]) for pos in jump_positions]\n    phase_shifts = np.random.uniform(0, 2*np.pi, n_jumps)\n\n    # Apply phase shifts to wave2\n    wave2_with_jumps = wave2.copy()\n    current_phase = 0\n\n    for i in range(n_jumps):\n        start_idx = jump_indices[i]\n        if i < n_jumps-1:\n            end_idx = jump_indices[i+1]\n        else:\n            end_idx = len(t)\n\n        current_phase += phase_shifts[i]\n        wave2_with_jumps[start_idx:end_idx] *= np.exp(1j * current_phase)\n\n    return wave1, wave2_with_jumps, jump_positions\n\n\ndef calc_correlation(wave, tau):\n    g = np.zeros(len(tau), dtype=complex)\n    N = len(wave)\n\n    for i, dt in enumerate(tau):\n        shift = int(dt * 10)\n        if shift >= N:\n            g[i] = 0\n        else:\n            g[i] = np.mean(wave[:(N-shift)] * np.conj(wave[shift:]))\n\n    return g / np.abs(g[0])\n\n# Generate waves with 30 jumps\nwave1, wave2, jump_positions = generate_waves_with_jumps(t, n_jumps=30)\nwave_total = wave1 + wave2\n\ng = calc_correlation(wave_total, tau)\n\n\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=get_size(10, 8))\n\nax1.plot(t[:2000], np.real(wave1[:2000]), label='Wave 1', alpha=0.9)\nax1.plot(t[:2000], np.real(wave2[:2000]), label='Wave 2', alpha=0.9)\nax1.plot(t[:2000], np.real(wave_total[:2000]), 'k-', label='Sum', lw=0.5)\nax1.set_xlim(0, 200)\n# Add vertical lines for phase jumps in wave plot\nfor pos in jump_positions:\n    ax1.axvline(x=pos, color='r', linestyle='--', alpha=0.3)\n\nax1.set_title('Superposition with Multiple Phase Jumps')\nax1.set_xlabel('time')\nax1.set_ylabel('amplitude')\nax1.legend(bbox_to_anchor=(1.05, 1), loc='upper left')\n\n# Plot correlation\nax2.plot(tau, np.abs(g))\n\nax2.set_title('|g⁽¹⁾(τ)|')\nax2.set_xlabel('τ')\nax2.set_ylabel('|g⁽¹⁾(τ)|')\nax2.set_xlim(0, 200)\nax2.set_ylim(0, 1)\n\n# Adjust layout\nplt.tight_layout()\nplt.subplots_adjust(right=0.85)\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Temporal correlation for two waves of same frequency showing decoherence due to multiple phase jumps. Vertical lines indicate positions of phase jumps.](03-lecture02_files/figure-html/cell-8-output-1.png){width=416 height=292 fig-align='center'}\n:::\n:::\n\n\n:::\nMultiple Wave Interference\n\n\nSo far we looked at the interference of two waves, which was a simplification as I mentioned already earlier. Commonly there will be a multitude of partial waves contribute to the oberved intereference. This is what we would like to have a look at now. We will do that in a quite general fashion, as the resulting formulas will appear several times again for different problems.\n\nNevertheless we will make a difference between\n\n- multiwave interference of waves with the constant amplitude\n- multiwave interference of waves with decreasing amplitude\n\nEspecially the latter is often occuring, if we have multiple reflections and each reflection is only a fraction of the incident amplitude.\n\n### Multiple Wave Interference with Constant Amplitude\n\nIn the case of constant amplitude (for example realized by a grating, which we talk about later), the total wave amplitude is given according to the picture below by\n\n$$\nU=U_1+U_2+U_1+U_3+\\ldots+U_M\n$$\n\nwhere we sum the amplitude over $M$ partial waves. Between the neighboring waves (e.g. $U_1$ and $U_2$), we will assume a phase difference (because of a path length difference for example), which we denote as $\\Delta \\phi$.\n\nThe amplitude of the p-th wave is then given by\n\n$$\nU_p=\\sqrt{I_0}e^{i(p-1)\\Delta \\phi}\n$$\n\nwith the index $p$ being an interger $p=1,2,\\ldots,M$, $h=e^{i\\Delta \\phi}$ and $\\sqrt{I_0}$ as the amplitude of each individual wave. The total amplitude $U$ can be then expressed as\n\n$$\nU=\\sqrt{I_0}\\left (1+h+h^2+\\ldots +h^{M-1}\\right)\n$$\n\nwhich is a geometric sum. We can apply the sum formula for geometric sums to obtain\n\n$$\nU=\\sqrt{I_0}\\frac{1-h^M}{1-h}=\\sqrt{I_0}\\frac{1-e^{iM\\Delta \\phi}}{1-e^{i\\Delta \\phi}}\n$$\n\nWe now have to calculate the intensity of the total amplitude\n\n$$\nI=|U|^2=I_{0}\\left | \\frac{e^{-iM\\Delta \\phi/2}-e^{iM\\Delta \\phi/2}}{e^{-i\\Delta \\phi/2}-e^{i\\Delta \\phi/2}}\\right |^2\n$$\n\nwhich we can further simplify to give\n\n$$\nI=I_{0}\\frac{\\sin^2(M\\Delta \\phi/2)}{\\sin^2(\\Delta \\phi/2)}\n$$\n\n::: {#figure-md layout-ncol=2}\n\n::: {#bb11e234 .cell execution_count=8}\n``` {.python .cell-code code-fold=\"true\"}\n# Parameters\nM = 6  # number of phasors\nphi = np.pi/8  # example phase difference between successive phasors\n\ndef plot_angle(ax, pos, angle, length=0.95, acol=\"C0\", **kwargs):\n    vec2 = np.array([np.cos(np.deg2rad(angle)), np.sin(np.deg2rad(angle))])\n    xy = np.c_[[length, 0], [0, 0], vec2*length].T + np.array(pos)\n    ax.plot(*xy.T, color=acol)\n    return AngleAnnotation(pos, xy[0], xy[2], ax=ax, **kwargs)\n\n# Calculate phasor positions\ndef calculate_phasors(phi, M):\n    # Initialize arrays for arrow start and end points\n    x_start = np.zeros(M)\n    y_start = np.zeros(M)\n    x_end = np.zeros(M)\n    y_end = np.zeros(M)\n\n    # Running sum of phasors\n    x_sum = 0\n    y_sum = 0\n\n    for i in range(M):\n        # Current phasor\n        x = np.cos(i * phi)\n        y = np.sin(i * phi)\n\n        # Store start point (end of previous phasor)\n        x_start[i] = x_sum\n        y_start[i] = y_sum\n\n        # Add current phasor\n        x_sum += x\n        y_sum += y\n\n        # Store end point\n        x_end[i] = x_sum\n        y_end[i] = y_sum\n\n    return x_start, y_start, x_end, y_end\n\nx_start, y_start, x_end, y_end = calculate_phasors(phi, M)\n\nplt.figure(figsize=get_size(6, 6))\nax = plt.gca()\n\nfor i in range(M):\n    plt.arrow(x_start[i], y_start[i],\n             x_end[i]-x_start[i], y_end[i]-y_start[i],\n             head_width=0.15, head_length=0.2, fc='k', ec='k',\n             length_includes_head=True,\n             label=f'E{i+1}' if i == 0 else \"\")\n\nplt.arrow(0, 0, x_end[-1], y_end[-1],\n         head_width=0.15, head_length=0.2, fc='r', ec='r',\n         length_includes_head=True, label='Resultant')\n\nax.set_aspect('equal')\nxx = np.linspace(-1, 3, 100)\nax.plot(xx,(xx-1)*np.tan(phi),'k--',lw=0.5)\nax.plot([1,3],[0,0],'k--',lw=0.5)\nkw = dict(size=195, unit=\"points\", text=r\"$\\Delta \\phi$\")\nplot_angle(ax, (1.0, 0), phi*180/np.pi, textposition=\"inside\", **kw)\nplt.axis('off')\nmax_range = max(abs(x_end[-1]), abs(y_end[-1])) * 1.2\nplt.xlim(-0, max_range/1.5)\nplt.ylim(-0.1, max_range/1.)\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Multiple wave interference of $M=6$ waves with a phase difference of $\\phi=\\pi/8$. The black arrows represent the individual waves, the red arrow the sum of all waves.](03-lecture02_files/figure-html/cell-9-output-1.png){width=142 height=194}\n:::\n:::\n\n\n::: {#cell-fig-multibeam2 .cell execution_count=9}\n``` {.python .cell-code code-fold=\"true\"}\n# Parameters\nM = 6\nphi = np.linspace(-4*np.pi, 4*np.pi, 10000)  # increased resolution\nI0 = 1\n\ndef multiple_beam_pattern(phi, M):\n    numerator = np.sin(M * phi/2)**2\n    denominator = np.sin(phi/2)**2\n    I = np.where(denominator != 0, numerator/denominator, M**2)\n    return I\n\nI = I0 * multiple_beam_pattern(phi, M)\n\nfirst_min = 2*np.pi/M  # theoretical value\n\ndef find_nearest(array, value):\n    array = np.asarray(array)\n    idx = (np.abs(array - value)).argmin()\n    return array[idx], idx\n\nhalf_max = M**2/2\n\nphi_positive = phi[phi >= 0]  # only positive values\nI_positive = I[phi >= 0]\n_, idx_half = find_nearest(I_positive, half_max)\nhalf_width = phi_positive[idx_half]\n\n# Create plot\nplt.figure(figsize=get_size(10, 6))\nplt.plot(phi/np.pi, I, 'b-', label=f'M={M}')\n\n#plt.plot(first_min/np.pi, multiple_beam_pattern(first_min, M), 'ro')\n#plt.annotate(f'First minimum\\nφ = 2π/M = {first_min/np.pi:.2f}π',\n\nplt.axvline(x=first_min/np.pi, color='r', linestyle='--', label=f'φ = 2π/M = {first_min/np.pi:.2f}π')\n\n#plt.plot(half_width/np.pi, half_max, 'go')\n\nplt.xlabel(r'phase $\\Delta \\phi/\\pi$')\nplt.ylabel('intensity I/I₀')\nplt.title(f'Multiple Beam Interference Pattern (M={M})')\nplt.ylim(0, M**2 + 15)\nplt.legend()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Multiple beam interference pattern for M=6 beams. The intensity distribution is shown as a function of the phase shift $\\phi$. The first minimum is at $\\phi=2\\pi/M$. The intensity distribution is symmetric around $\\phi=0$.](03-lecture02_files/figure-html/fig-multibeam2-output-1.png){#fig-multibeam2 width=345 height=241 fig-align='center'}\n:::\n:::\n\n\n:::\n\nThe result is therefore an oscillating function. The numerator $\\sin^2(M\\Delta \\phi/2)$ shows and oscillation frequency, which is by a factor of $M$ higher than the one in the denominator $\\sin^2 (\\Delta \\phi/2)$.\nTherefore the intensity pattern is oscillating rapidly and creating a first minimum at\n\n$$\n\\Delta \\phi=\\frac{2\\pi}{M}\n$$\n\nThis is an important result, since it shows that the number of sources $M$ determines the position of the first minimum and the interference peak gets narrower with increasing $M$. Since the phase difference $\\Delta \\phi$ between neighboring sources is the same as for the double slit experiment, i.e. $\\Delta \\phi=2\\pi d/\\lambda \\sin(\\theta)$, we can also determine the angular position of the first minimum. This is given by\n\n$$\n\\sin(\\theta_\\textrm{min})=\\frac{1}{M}\\frac{\\lambda}{d}\n$$\n\nThis again has the common feature that it scales as $\\lambda/d$.\nA special situation occurs, whenever the numerator and the denominator become zero. This will happen whenever\n\n$$\n\\Delta \\phi=m 2\\pi\n$$\n\nwhere $m$ is an integer and denotes the interference order, i.e. the number of wavelength that neighboring partial waves have as path length difference.\nIn this case, the intensity distributiion will give us\n\n$$\nI=I_0 \\frac{0}{0}\n$$\n\nand we have to determine the limit with the help of l'Hospitals rule. The outcome of this calculation is, that\n\n$$\nI(\\Delta \\phi=m2\\Delta \\pi)=M^2 I_0\n$$\n\nwhich can be also realized when using the small angle approximation for the sine functions.\n\n#### Wavevector Representation\n\nWe would like to introduce a different representation of the multiple wave interference of the grating, which is quite insightful.\nThe first order ($m=1$) constructive interference condition is given by\n\n$$\n\\frac{1}{\\lambda}\\sin{\\theta}= \\frac{1}{d}\n$$\n\nwhich also means that\n\n$$\n\\frac{2\\pi}{\\lambda}\\sin{\\theta}= \\frac{2\\pi}{d}\n$$\n\nThis can be written as\n\n$$\nk \\sin{\\theta}= K\n$$\n\nwhere $k$ is the magnitude of the wavevector of the light and $K$ is the wavevector magnitude that corresponds to the grating period $d$. As the magnitude of the wavevector of the light is conserved, the wavevectors of the incident light and the light traveling along the direction of the first interence peak form the sides of an equilateral triangle. This is shown in the following figure.\n\n::: {#ef3da485 .cell execution_count=10}\n``` {.python .cell-code code-fold=\"true\"}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\nk = 1  # Magnitude of k₁ and k₂\n\norigin = np.array([0, 0])\n\nk1 = np.array([k, 0])\n\ntheta_deg = 30  # θ = 30 degrees\ntheta_rad = np.deg2rad(theta_deg)\n\nk2 = k * np.array([np.cos(theta_rad), np.sin(theta_rad)])\n\nK = k2 - k1\n\npoint_O = origin\npoint_A = point_O + k1\npoint_B = point_O + k2\n\n\nplt.figure(figsize=get_size(10, 10))\nax = plt.gca()\n\n# Plot vector k₁\nax.arrow(point_O[0], point_O[1], k1[0], k1[1],\n         head_width=0.02, head_length=0.03, fc='k', ec='k', length_includes_head=True)\n\n\nax.arrow(point_A[0], point_A[1], K[0], K[1],\n         head_width=0.02, head_length=0.03, fc='b', ec='b', length_includes_head=True)\n\nax.arrow(point_O[0], point_O[1], k2[0], k2[1],\n         head_width=0.02, head_length=0.03, fc='k', ec='k', length_includes_head=True)\n\n# Label vectors\nax.text(k1[0]/2 - 0.05, k1[1]/2 - 0.05, r'$\\mathbf{k}$', fontsize=14, color='k')\nax.text(point_A[0] + K[0]/2 , point_A[1] + K[1]/2 + 0.05, r'$\\mathbf{K}$', fontsize=14, color='b')\nax.text(k2[0]/2 + 0.0, k2[1]/2+0.1, r'$\\mathbf{k}$', fontsize=14, color='k')\n\n# Indicate angle θ between k₁ and k₂ at the origin\narc_radius = 0.3  # Radius of the arc representing θ\nangle_range = np.linspace(0, theta_rad, 100)\narc_x = arc_radius * np.cos(angle_range)\narc_y = arc_radius * np.sin(angle_range)\nax.plot(arc_x, arc_y, color='k')\n\nax.text(arc_radius * np.cos(theta_rad / 2) + 0.02,\n        arc_radius * np.sin(theta_rad / 2) + 0.02,\n        r'$\\theta$', fontsize=14)\n\n# Set equal aspect ratio\nax.set_aspect('equal', adjustable='box')\n\nall_x = [point_O[0], point_A[0], point_B[0]]\nall_y = [point_O[1], point_A[1], point_B[1]]\nmargin = 0.2\nax.set_xlim(min(all_x) - margin, max(all_x) + margin)\nax.set_ylim(min(all_y) - margin, max(all_y) + margin)\nplt.axis('off')\n\n# Display the plot\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Wavevector summation for the diffraction grating. The wavevector of the incident light $k$ and the wavevector of the light traveling along the direction of the first interference peak $K$ form an equilateral triangle.](03-lecture02_files/figure-html/cell-11-output-1.png){width=312 height=208 fig-align='center'}\n:::\n:::\n\n\nThis means that the diffraction grating is providing a wavevector $K$ to alter the direction of the incident light. This is again a common feature reappearing in many situations as for example in the X-ray diffraction of crystals.\n\n\n::: {.callout-note collapse=true}\n### Multiple Wave Interference with Decreasing Amplitude\n\nWe will turn our attention now to a slight modification of the previous multiwave interference. We will introduce a decreasing amplitude of the individual waves. The first wave shall have an amplitude $U_1=\\sqrt{I_0}$. The next wave, however, will not only be phase shifted but also have a smaller amplitude.\n\n$$\nU_2=h U_1\n$$\n\nwhere $h=re^{i\\phi}$ with $|h|=r<1$. $r$ can be regarded as a reflection coefficient, which deminishes the amplitude of the incident wave. According to that the intensity is reduced by\n\n$$\nI_2=|U_2|^2=|h U_1|^2=r^2 I_1\n$$\n\nThe intensity of the incident wave is multiplied by a  factor $r^2$, while the amplitude is multiplied by $r$. Note that the phase factor $e^{i\\Delta\\phi}$ is removed when taking the square of this complex number.\n\n::: {.callout-note}\n## Intensity at Boundaries\n\nThe amplitude of the reflected wave is diminished by a factor\n$r\\le 1$, which is called the reflection coefficient. The intensity is diminished by a factor $R=|r|^2\\le1$, which is the **reflectance**.\n\nIn the absence of absorption, reflectance $R$  and **transmittance** $T$ add to one due to energy conservation.\n\n$$\nR+T=1\n$$\n:::\n\nConsequently, the third wave would be now $U_3=hU_2=h^2U_1$.\nThe total amplitude is thus\n\n$$\nU=U_1+U_2+U_3+\\ldots+U_M = \\sqrt{I_0}(1+h+h^2+\\ldots)\n$$\n\n:::{#figure-fabry1}\n\n::: {#79be6eda .cell execution_count=11}\n``` {.python .cell-code code-fold=\"true\"}\nM = 18  # number of phasors\nphi = np.pi/6  # example phase difference between successive phasors\nr = 0.95  # reduction factor for each subsequent phasor\n\ndef plot_angle(ax, pos, angle, length=0.95, acol=\"C0\", **kwargs):\n    vec2 = np.array([np.cos(np.deg2rad(angle)), np.sin(np.deg2rad(angle))])\n    xy = np.c_[[length, 0], [0, 0], vec2*length].T + np.array(pos)\n    ax.plot(*xy.T, color=acol)\n    return AngleAnnotation(pos, xy[0], xy[2], ax=ax, **kwargs)\n\ndef calculate_phasors(phi, M, r):\n    x_start = np.zeros(M)\n    y_start = np.zeros(M)\n    x_end = np.zeros(M)\n    y_end = np.zeros(M)\n\n    x_sum = 0\n    y_sum = 0\n\n    for i in range(M):\n        amplitude = r**i  # exponential decrease\n        x = amplitude * np.cos(i * phi)\n        y = amplitude * np.sin(i * phi)\n\n        x_start[i] = x_sum\n        y_start[i] = y_sum\n\n        x_sum += x\n        y_sum += y\n\n        x_end[i] = x_sum\n        y_end[i] = y_sum\n\n    return x_start, y_start, x_end, y_end\n\nx_start, y_start, x_end, y_end = calculate_phasors(phi, M, r)\n\nplt.figure(figsize=get_size(6, 6),dpi=150)\nax = plt.gca()\n\nfor i in range(M):\n    plt.arrow(x_start[i], y_start[i],\n             x_end[i]-x_start[i], y_end[i]-y_start[i],\n             head_width=0.15, head_length=0.2,\n             fc='k', ec='k',\n             length_includes_head=True,\n             label=f'E{i+1}' if i == 0 else \"\")\n\nplt.arrow(0, 0, x_end[-1], y_end[-1],\n         head_width=0.15, head_length=0.2, fc='r', ec='r',\n         length_includes_head=True, label='Resultant')\n\nax.set_aspect('equal')\nxx = np.linspace(-1, 3, 100)\nax.plot(xx,(xx-1)*np.tan(phi),'k--',lw=0.5)\nax.plot([1,3],[0,0],'k--',lw=0.5)\nkw = dict(size=195, unit=\"points\", text=r\"$\\phi$\")\nplot_angle(ax, (1.0, 0), phi*180/np.pi, textposition=\"inside\", **kw)\nplt.axis('off')\nmax_range = max(abs(x_end[-1]), abs(y_end[-1])) * 1.2\nplt.xlim(-max_range/1.8, max_range/0.8)\nplt.ylim(-0.1, max_range/0.9)\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Phase construction of a multiwave intereference with M waves with decreasing amplitude due to a reflection coefficient $r=0.95$.](03-lecture02_files/figure-html/cell-12-output-1.png){width=304 height=203}\n:::\n:::\n\n\n:::\n\n:::{#figure-fabry2}\n\n::: {#8e5aa493 .cell execution_count=12}\n``` {.python .cell-code code-fold=\"true\"}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Create phase array from -2π to 2π\nphi = np.linspace(-2*np.pi, 2*np.pi, 1000)\n\ndef calculate_intensity(phi, F):\n    return 1/(1 + 4*(F/np.pi)**2 * np.sin(phi/2)**2)\n\nplt.figure(figsize=get_size(10, 6))\n\nfinesse_values = [1, 4, 20]\nstyles = ['-', '--', ':']\n\nfor F, style in zip(finesse_values, styles):\n    I = calculate_intensity(phi, F)\n    plt.plot(phi/np.pi, I, style, label=f'$\\\\mathcal{{F}}={F}$')\n\nplt.xlabel('Phase $\\\\phi/\\\\pi$')\nplt.ylabel('$I/I_{\\\\mathrm{max}}$')\nplt.grid(True, alpha=0.3)\nplt.legend()\nplt.ylim(0, 1.1)\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Multiple wave interference with decreasing amplitude. The graph shows the intensity distribution over the phase angle $\\phi$ for different values of the Finesse $\\mathcal{F}$.](03-lecture02_files/figure-html/cell-13-output-1.png){width=350 height=225}\n:::\n:::\n\n\n:::\n\n\nThis yields again\n\n$$\nU=\\sqrt{I_0}\\frac{(1-h^M)}{1-h}=\\frac{\\sqrt{I_0}}{1-r e^{i\\Delta\\phi}}\n$$\n\nCalculating the intensity of the waves is giving\n\n$$\nI=|U|^2=\\frac{I_{0}}{|1-re^{i\\Delta\\phi}|^2}=\\frac{I_0}{(1-r)^2+4r\\sin^2(\\Delta\\phi/2)}\n$$\n\nwhich is also known as the **Airy function**. This function can be further simplified by the following abbrevations\n\n$$\nI_{\\rm max}=\\frac{I_0}{(1-r)^2}\n$$\n\nand\n\n$$\n\\mathcal{F}=\\frac{\\pi \\sqrt{r}}{1-r}\n$$\n\nwhere the latter is called the *Finesse*. With those abbrevations, we obtain\n\n$$\nI=\\frac{I_{\\rm max}}{1+4\\left(\\frac{\\mathcal{F}}{\\pi}\\right)^2\\sin^{2}(\\Delta\\phi/2)}\n$$\n\nfor the interference of multiple waves with decreasing amplitude.\n\nThis intensity distribution has a different shape than the one we obtained for multiple waves with the same amplitude.\n\nWe clearly observe that with increasing Finesse the intensity maxima, which occur at multiples fo $\\pi$ get much narrower. In addition the regions between the maxima show better contrast and fopr higher Finesse we get complete destructive interference.\n:::\n\n### Light beating\n\n#### Beating of two waves\nLet us consider now interference in the time domain. We introduce two monochromatic waves of frequencies $\\nu_1$ and $\\nu_2$. We will denote their amplitudes by $\\sqrt{I_1}$ and $\\sqrt{I_2}$.\n\nThe total amplitude is thus\n\n$$\nU=U_1+U_2 = \\sqrt{I_1} \\exp(i2\\pi\\nu_1 t) + \\sqrt{I_2} \\exp(i2\\pi\\nu_2 t)\n$$\n\nsuch that we obtain an Intensity\n\n$$\nI=|U|^2 = I_1 + I_2 + 2\\sqrt{I_1I_2}\\cos(2\\pi(\\nu_1-\\nu_2)t)\n$$\n\n\nThe intensity is thus time dependent and oscillates at a frequency $\\nu_1-\\nu_2$, which is the so-called beating frequency. Similar schemes are used in **optical heterodyne detection** but also in acoustics when tuning your guitar.\n\n\n#### Multiple wave beating and pulse generation\n\nConsider now a whole set of $M=2L+1$ each with an amplitude $\\sqrt{I_0}$. The frequencies of the waves are given by $\\nu_q=\\nu_0+q\\Delta\\nu$ with $q=-L,\\dots,L$ with $\\nu_0$ beeing the center frequency of the spectrum and $\\Delta \\nu$ the frequency spacing. We will assume that $\\Delta nu<<\\nu_0$ such that the total amplitude of the waves is given by\n\n$$\nU=\\sum_{q=-L}^L \\sqrt{I_0} \\exp(i2\\pi(\\nu_0+q\\Delta\\nu)t)\n$$\n\nThe total intensity can then be calculated in the same way as for the multiple source in space before. Using $\\phi=2\\pi \\Delta \\nu t$ we obtained\n$$\nI(t)=I_0 \\frac{\\sin^2(M\\pi t/T)}{\\sin^2(\\pi t/T)}\n$$\n\nwith $T=1/\\Delta\\nu$ and a maximum intensity of $I_{\\rm max}=M^2 I_0$.\n\n::: {#cell-fig-pulse .cell execution_count=13}\n``` {.python .cell-code code-fold=\"true\"}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Parameters\nDelta_nu = 1e9  # 1 GHz\nM = 1000\nI0 = 1  # Normalized initial intensity\nT = 1/Delta_nu  # 1 ns\npulse_width = T/M  # 1 ps\n\n# Create figure with two subplots\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=get_size(15, 10),\n                             gridspec_kw={'width_ratios': [2, 1]})\n\n# Time array for main plot showing multiple pulses\nt_main = np.linspace(-2*T, 2*T, 20000)\n\n# Time array for inset showing single pulse detail\nt_detail = np.linspace(-5*pulse_width, 5*pulse_width, 10000)\n\n# Calculate intensity function (avoiding division by zero)\ndef intensity(t, M, T, I0):\n    # Small value to prevent division by zero\n    eps = 1e-10\n    # Calculate using the formula\n    num = np.sin(M * np.pi * t / T)**2\n    den = np.sin(np.pi * t / T)**2\n    # Handle points where denominator is near zero\n    near_zero = np.abs(np.sin(np.pi * t / T)) < eps\n\n    result = np.zeros_like(t, dtype=float)\n    # For normal points, use formula\n    mask = ~near_zero\n    result[mask] = I0 * num[mask] / den[mask]\n    # For points where denominator is near zero, use limit value\n    result[near_zero] = M**2 * I0\n\n    return result\n\n# Calculate intensities\nI_main = intensity(t_main, M, T, I0)\nI_detail = intensity(t_detail, M, T, I0)\n\n# Maximum intensity\nmax_intensity = M**2 * I0\n\n# Main plot showing multiple pulses\nax1.plot(t_main*1e9, I_main, 'b-')\nax1.set_xlabel('time [ns]')\nax1.set_ylabel(r' $I/I_{0}$')\nax1.grid(True, alpha=0.3)\n\n# Mark maximum intensity\nax1.axhline(y=max_intensity, color='r', linestyle='--')\n\n# Mark period T\nax1.annotate('', xy=(T*1e9, 0.5e6), xytext=(0, 0.5e6),\n           arrowprops=dict(arrowstyle='<->', color='g'))\nax1.text(0.5*T*1e9, max_intensity*1.1, f'T = 1/Δν = {T*1e9:.1f} ns',\n        color='g', ha='center')\n\n\nax1.set_ylim(0, max_intensity*1.2)\n\n# Detail plot showing single pulse\nax2.plot(t_detail*1e12, I_detail, 'b-')\nax2.set_xlabel('time [ps]')\nax2.set_ylabel(r'$I/I_{0}$')\n\n\n# Mark pulse width\nax2.annotate('', xy=(-pulse_width/1*1e12, max_intensity*1.05),\n           xytext=(pulse_width/1*1e12, max_intensity*1.05),\n           arrowprops=dict(arrowstyle='<->', color='m'))\nax2.text(0, max_intensity*1.1, f'T/M = {pulse_width*1e12:.1f} ps',\n        color='m', ha='center')\n\nax2.set_ylim(0, max_intensity*1.2)\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Multiple wave beating with M=1000 monochromatic waves separated by Δν=1 GHz. The intensity oscillates with period T=1/Δν=1 ns. Each pulse has a width of approximately T/M=1 ps with maximum intensity I_max=M²I₀.](03-lecture02_files/figure-html/fig-pulse-output-1.png){#fig-pulse width=557 height=367 fig-align='center'}\n:::\n:::\n\n\n### Frequency Combs: Phase-Coherent Temporal Interference\n\nThe pulse generation we just examined leads us to an important concept in modern optics: frequency combs. A frequency comb is a spectrum consisting of a series of discrete, equally spaced frequency lines that results from a train of phase-coherent pulses in the time domain.\n\n#### From Pulse Trains to Frequency Combs\n\nLet's extend our understanding of multiple wave beating to include phase coherence. When we have a set of equidistant frequency components that maintain a fixed phase relationship, the resulting time-domain signal is a periodic train of pulses. Conversely, a periodic train of pulses in the time domain corresponds to a frequency comb in the spectral domain.\n\nThe relationship between these domains is described by the Fourier transform. For a pulse train with repetition rate $f_{rep} = \\Delta\\nu$ (the spacing between frequency components), the frequency spectrum consists of lines at:\n\n$$f_n = f_0 + n \\cdot f_{rep}$$\n\nwhere $f_0$ is the carrier-envelope offset frequency and $n$ is an integer.\n\n#### Mathematical Description\n\nConsider a train of pulses described by the electric field:\n\n$$E(t) = \\sum_{m=-\\infty}^{\\infty} A(t - m T_{rep}) e^{i[\\omega_c(t - m T_{rep}) + \\phi_{CE} \\cdot m + \\phi_0]}$$\n\nwhere:\n- $A(t)$ is the pulse envelope\n- $T_{rep} = 1/f_{rep}$ is the pulse repetition period\n- $\\omega_c$ is the carrier frequency\n- $\\phi_{CE}$ is the carrier-envelope phase slip (the phase shift from pulse to pulse)\n- $\\phi_0$ is a constant phase\n\nThe Fourier transform of this pulse train gives us a frequency comb with:\n\n$$f_0 = \\frac{\\phi_{CE}}{2\\pi} \\cdot f_{rep}$$\n\nThis carrier-envelope offset frequency ($f_0$) is crucial for determining the absolute positions of the comb lines.\n\n::: {#cell-fig-freq-comb .cell execution_count=14}\n``` {.python .cell-code code-fold=\"true\"}\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.fft import fft, fftfreq, fftshift\n\n# Parameters\nf_rep = 0.1e12  # 100 GHz repetition rate\nf_0 = 0.2 * f_rep  # Carrier-envelope offset frequency (20% of f_rep)\nf_c = 2e12  # 2 THz carrier frequency (simplified for visualization)\npulse_fwhm = 50e-15  # 50 fs pulse width\n\n# Time domain\nN = 2**14  # Number of points for good FFT resolution\nT_total = 100e-12  # 100 ps total window (multiple pulses)\ndt = T_total / N\nt = np.linspace(0, T_total, N, endpoint=False)\n\n# Pulse envelope function (Gaussian)\ndef gaussian_envelope(t, t0, fwhm):\n    # Convert FWHM to standard deviation\n    sigma = fwhm / (2 * np.sqrt(2 * np.log(2)))\n    return np.exp(-((t - t0) ** 2) / (2 * sigma ** 2))\n\n# Generate a train of pulses with carrier-envelope phase evolution\ndef pulse_train(t, f_rep, f_c, f_0, fwhm):\n    T_rep = 1/f_rep\n    omega_c = 2 * np.pi * f_c\n    phi_CE = 2 * np.pi * f_0 / f_rep  # Phase slip per pulse\n\n    # Initialize field\n    E = np.zeros_like(t, dtype=complex)\n\n    # Add multiple pulses\n    for m in range(int(T_total * f_rep) + 5):  # +5 to ensure we capture all pulses\n        t0 = m * T_rep\n        if t0 > T_total:\n            break\n\n        # Pulse envelope\n        env = gaussian_envelope(t, t0, fwhm)\n\n        # Carrier with phase evolution\n        carrier = np.exp(1j * (omega_c * (t - t0) + phi_CE * m))\n\n        # Add pulse to field\n        E += env * carrier\n\n    return E\n\n# Generate the electric field\nE_t = pulse_train(t, f_rep, f_c, f_0, pulse_fwhm)\n\n# Calculate intensity in time domain\nI_t = np.abs(E_t)**2\n\n# Calculate the frequency spectrum\nE_f = fftshift(fft(E_t))\nf = fftshift(fftfreq(N, dt))  # Frequency axis\nI_f = np.abs(E_f)**2\n\n# Normalize for better visualization\nI_t_norm = I_t / np.max(I_t)\nI_f_norm = I_f / np.max(I_f)\n\n# Create figure with two subplots\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=get_size(15, 10))\n\n# Time domain plot\nax1.plot(t*1e12, I_t_norm, 'b-')\nax1.set_xlabel('Time [ps]')\nax1.set_ylabel('Normalized Intensity')\nax1.set_title('Pulse Train (Time Domain)')\nax1.grid(True, alpha=0.3)\nax1.set_xlim(0, 50)  # Show a subset of the time window\n\n# Annotate T_rep\nt_rep = 1/f_rep\nax1.annotate('', xy=(t_rep*1e12, 0.1), xytext=(0, 0.1),\n             arrowprops=dict(arrowstyle='<->', color='red'))\nax1.text(t_rep*1e12/2, 0.15, f'$T_{{rep}}$ = {t_rep*1e12:.1f} ps',\n         ha='center', color='red')\n\n# Frequency domain plot - zoomed around carrier frequency\nf_min = f_c - 5*f_rep\nf_max = f_c + 5*f_rep\nf_mask = (f > f_min) & (f < f_max)\n\nax2.plot(f[f_mask]*1e-12, I_f_norm[f_mask], 'g-')\nax2.set_xlabel('Frequency [THz]')\nax2.set_ylabel('Normalized Spectral Power')\nax2.set_title('Frequency Comb')\nax2.grid(True, alpha=0.3)\n\n# Annotate frequency spacing\nmax_peaks = np.where(I_f_norm[f_mask] > 0.5)[0]\nif len(max_peaks) >= 2:\n    peak_indices = np.sort(max_peaks)[:2]\n    peak_freqs = f[f_mask][peak_indices]\n    ax2.annotate('', xy=(peak_freqs[1]*1e-12, 0.5), xytext=(peak_freqs[0]*1e-12, 0.5),\n                 arrowprops=dict(arrowstyle='<->', color='red'))\n    ax2.text((peak_freqs[0] + peak_freqs[1])*1e-12/2, 0.6,\n             f'$f_{{rep}}$ = {f_rep*1e-9:.0f} GHz', ha='center', color='red')\n\n# Mark f_0\nax2.annotate('$f_0$', xy=(f_0*1e-12, 0.3), xytext=(f_0*1e-12, 0.4),\n             arrowprops=dict(arrowstyle='->', color='purple'))\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Demonstration of a frequency comb. (Left) Time domain representation showing a train of phase-coherent pulses. (Right) Frequency domain representation showing equally spaced frequency lines forming a comb structure.](03-lecture02_files/figure-html/fig-freq-comb-output-1.png){#fig-freq-comb width=552 height=367 fig-align='center'}\n:::\n:::\n\n\n#### Applications of Frequency Combs\n\nFrequency combs have revolutionized precision measurements in physics and enabled numerous applications:\n\n1. **Optical Clocks**: Frequency combs provide a \"gear mechanism\" to count optical frequencies, enabling optical atomic clocks that are orders of magnitude more precise than conventional atomic clocks.\n\n2. **Precision Spectroscopy**: The precise and stable frequency references allow for high-resolution molecular spectroscopy.\n\n3. **Calibration of Astronomical Spectrographs**: Frequency combs enable the detection of Earth-like exoplanets by providing precise wavelength calibration for astronomical instruments.\n\n4. **Distance Measurements**: They enable precise absolute distance measurements used in applications from gravitational wave detectors to satellite formation flying.\n\n5. **Telecommunications**: Frequency combs can be used for wavelength-division multiplexing in optical communications.\n\n#### Connection to Mode-Locked Lasers\n\nIn practice, frequency combs are often generated using mode-locked lasers. In such lasers, multiple longitudinal modes of the laser cavity oscillate with a fixed phase relationship, resulting in short pulses. The Fourier transform of these regularly spaced pulses is precisely the frequency comb.\n\nThe mode-locking can be achieved through various mechanisms:\n\n- **Active mode-locking**: Using an external modulator driven at the cavity round-trip frequency\n- **Passive mode-locking**: Using saturable absorbers or Kerr-lens mode-locking\n\nThe 2005 Nobel Prize in Physics was awarded to Theodor W. Hänsch and John L. Hall for their contributions to the development of laser-based precision spectroscopy, including the optical frequency comb technique.\n\n#### The Fundamental Link Between Time and Frequency Domains\n\nFrequency combs beautifully illustrate the duality between time and frequency domains in physics. A perfectly periodic sequence of events in time (the pulse train) corresponds to discrete, equally spaced frequencies. The more precise and stable the temporal pattern, the more precise and stable the frequency components.\n\nThis duality is fundamental to many areas of physics and engineering, from quantum mechanics to signal processing, and frequency combs represent one of its most elegant and useful manifestations in optics.\n\n",
    "supporting": [
      "03-lecture02_files"
    ],
    "filters": [],
    "includes": {}
  }
}